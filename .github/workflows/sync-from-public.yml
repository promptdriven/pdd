name: Sync from Public Repos
on:
  repository_dispatch:
    types: [sync-from-public]
  workflow_dispatch:
    inputs:
      source:
        description: 'Source repo'
        required: true
        default: 'promptdriven/pdd'
        type: choice
        options:
          - promptdriven/pdd
          - promptdriven/pdd_cap

permissions:
  contents: write
  pull-requests: write

jobs:
  create-sync-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Determine source repo
        id: source
        run: |
          SOURCE="${{ github.event.client_payload.source || inputs.source || 'promptdriven/pdd' }}"
          TRIGGER_SHA="${{ github.event.client_payload.sha || '' }}"

          echo "repo=$SOURCE" >> $GITHUB_OUTPUT
          echo "trigger_sha=$TRIGGER_SHA" >> $GITHUB_OUTPUT

          if [[ "$SOURCE" == "promptdriven/pdd_cap" ]]; then
            echo "url=https://github.com/promptdriven/pdd_cap.git" >> $GITHUB_OUTPUT
            echo "name=public-cap" >> $GITHUB_OUTPUT
            echo "include_prompts=true" >> $GITHUB_OUTPUT
          else
            echo "url=https://github.com/promptdriven/pdd.git" >> $GITHUB_OUTPUT
            echo "name=public" >> $GITHUB_OUTPUT
            echo "include_prompts=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: pip install -e .

      - name: Add remote and fetch
        env:
          CAP_TOKEN: ${{ secrets.CAP_REPO_TOKEN }}
        run: |
          if [[ "${{ steps.source.outputs.name }}" == "public-cap" ]]; then
            echo "CAP_TOKEN length: ${#CAP_TOKEN}"
            echo "Setting up auth for pdd_cap..."
            git remote add ${{ steps.source.outputs.name }} "https://x-access-token:${CAP_TOKEN}@github.com/promptdriven/pdd_cap.git" 2>/dev/null || true
          else
            git remote add ${{ steps.source.outputs.name }} ${{ steps.source.outputs.url }} 2>/dev/null || true
          fi
          git remote -v
          git fetch ${{ steps.source.outputs.name }} main

      - name: Find changed files
        id: changed
        run: |
          REMOTE="${{ steps.source.outputs.name }}"
          TRIGGER_SHA="${{ steps.source.outputs.trigger_sha }}"

          # Read patterns from .sync-config.yml
          PATTERNS=()

          # Parse shared patterns (lines after "shared:" until next section or EOF)
          IN_SHARED=false
          IN_CAP=false
          while IFS= read -r line; do
            # Detect section headers
            if [[ "$line" =~ ^shared: ]]; then
              IN_SHARED=true
              IN_CAP=false
              continue
            elif [[ "$line" =~ ^cap_only: ]]; then
              IN_SHARED=false
              IN_CAP=true
              continue
            elif [[ "$line" =~ ^[a-z_]+: ]]; then
              IN_SHARED=false
              IN_CAP=false
              continue
            fi

            # Extract pattern from "  - pattern" lines
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]](.+)$ ]]; then
              pattern="${BASH_REMATCH[1]}"
              if $IN_SHARED; then
                PATTERNS+=("$pattern")
              elif $IN_CAP && [[ "${{ steps.source.outputs.include_prompts }}" == "true" ]]; then
                PATTERNS+=("$pattern")
              fi
            fi
          done < .sync-config.yml

          echo "Using patterns: ${PATTERNS[*]}"

          # Only sync files from the specific triggering commit
          # This prevents reverting private-only changes
          if [ -n "$TRIGGER_SHA" ]; then
            echo "Syncing files from commit: $TRIGGER_SHA"

            # Get files changed in the triggering commit only
            # Use ^1 to compare with first parent (handles merge commits)
            CHANGED=$(git diff --name-only "$TRIGGER_SHA^1" "$TRIGGER_SHA" -- "${PATTERNS[@]}" 2>/dev/null || echo "")
          else
            echo "No trigger SHA provided (manual run) - skipping sync"
            echo "To sync manually, use repository_dispatch with a specific SHA"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ -z "$CHANGED" ]; then
            echo "No matching files changed in commit $TRIGGER_SHA"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changed files:"
            echo "$CHANGED"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "files_b64=$(echo "$CHANGED" | base64 -w0)" >> $GITHUB_OUTPUT

            # Detect files with local modifications that will be overwritten
            # Only flag if private differs from BOTH old and new public versions
            # (If private matches old version, it's just outdated, not a local modification)
            CONFLICTS=""
            while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                # Check if private differs from new public version
                if ! git diff --quiet HEAD "$TRIGGER_SHA" -- "$file" 2>/dev/null; then
                  # Also check if private differs from old public version
                  if ! git diff --quiet HEAD "$TRIGGER_SHA^1" -- "$file" 2>/dev/null; then
                    # Private differs from both = has local modifications
                    CONFLICTS="$CONFLICTS$file\n"
                  fi
                fi
              fi
            done <<< "$CHANGED"

            if [ -n "$CONFLICTS" ]; then
              echo "‚ö†Ô∏è Files with local modifications that will be overwritten:"
              echo -e "$CONFLICTS"
              echo "conflicts_b64=$(echo -e "$CONFLICTS" | base64 -w0)" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Apply changes
        if: steps.changed.outputs.has_changes == 'true'
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"

          TRIGGER_SHA="${{ steps.source.outputs.trigger_sha }}"
          SOURCE="${{ steps.source.outputs.repo }}"
          SAFE_SOURCE="${SOURCE//\//-}"

          git checkout -b "sync/from-$SAFE_SOURCE-${{ github.run_id }}-${{ github.run_attempt }}"

          echo "${{ steps.changed.outputs.files_b64 }}" | base64 -d | while read -r file; do
            if [ -n "$file" ]; then
              echo "Syncing: $file"
              mkdir -p "$(dirname "$file")"
              # Checkout the file at the trigger commit (not HEAD of public/main)
              # This ensures we get exactly what was in the merged PR
              git checkout "$TRIGGER_SHA" -- "$file" || echo "Skip: $file"
            fi
          done

      - name: Run tests
        if: steps.changed.outputs.has_changes == 'true'
        continue-on-error: true
        run: |
          pytest tests/test_code_generator_main.py tests/test_commands_modify.py -v --tb=short

      - name: Create PR
        if: steps.changed.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SOURCE="${{ steps.source.outputs.repo }}"
          SAFE_SOURCE="${SOURCE//\//-}"
          FILES=$(echo "${{ steps.changed.outputs.files_b64 }}" | base64 -d)

          git add -A
          git diff --staged --quiet && exit 0

          git commit -m "sync: Import from $SOURCE"
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"
          git push -u origin "sync/from-$SAFE_SOURCE-${{ github.run_id }}-${{ github.run_attempt }}"

          # Build conflict warning if any
          CONFLICTS_B64="${{ steps.changed.outputs.conflicts_b64 }}"
          CONFLICT_WARNING=""
          if [ -n "$CONFLICTS_B64" ]; then
            CONFLICTS=$(echo "$CONFLICTS_B64" | base64 -d)
            CONFLICT_WARNING="
          ‚ö†Ô∏è **WARNING: These files have local modifications that will be overwritten:**
          \`\`\`
          $CONFLICTS
          \`\`\`
          Please review these changes carefully - local fixes may be lost!

          "
          fi

          gh pr create \
            --title "üîÑ Sync from $SOURCE" \
            --body "$(cat <<EOF
          Automated sync from [$SOURCE](https://github.com/$SOURCE)

          **Commit:** \`${{ github.event.client_payload.sha || 'manual' }}\`
          $CONFLICT_WARNING
          **Changed files:**
          \`\`\`
          $FILES
          \`\`\`

          ‚ö†Ô∏è Review carefully before merging.
          EOF
          )" \
            --label "sync"
