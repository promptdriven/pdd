name: PR Tests on Google Cloud Run

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to test (optional)'
        required: false
        type: string
      branch:
        description: 'Branch to test'
        required: false
        type: string
        default: 'main'

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: ${{ secrets.GCP_REGION || 'us-central1' }}
  JOB_NAME: pdd-test-runner
  INFISICAL_PROJECT_ID: ${{ secrets.INFISICAL_PROJECT_ID }}

jobs:
  run-tests-on-cloud:
    name: Execute Tests on Google Cloud Run
    runs-on: ubuntu-latest
    timeout-minutes: 90
    
    permissions:
      contents: read
      pull-requests: write
      id-token: write
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || inputs.branch || github.sha }}
          fetch-depth: 0
          
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Build and push test image to Artifact Registry
        id: build_image
        run: |
          # Configure Docker for GCR
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev
          
          # Build image with current code
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_URI="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/pdd-images/pdd-test-runner:${IMAGE_TAG}"
          
          echo "Building test image..."
          docker build -f Dockerfile.cloud-test -t "${IMAGE_URI}" .
          
          echo "Pushing image..."
          docker push "${IMAGE_URI}"
          
          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Built and pushed: ${IMAGE_URI}"
          
      - name: Create or update Cloud Run Job
        id: setup_job
        run: |
          IMAGE_URI="${{ steps.build_image.outputs.image_uri }}"
          
          # Check if job exists
          if gcloud run jobs describe ${{ env.JOB_NAME }} --region ${{ env.GCP_REGION }} 2>/dev/null; then
            echo "Updating existing Cloud Run Job..."
            gcloud run jobs update ${{ env.JOB_NAME }} \
              --image "${IMAGE_URI}" \
              --region ${{ env.GCP_REGION }} \
              --memory 4Gi \
              --cpu 2 \
              --max-retries 0 \
              --task-timeout 3600 \
              --set-env-vars "INFISICAL_PROJECT_ID=${{ env.INFISICAL_PROJECT_ID }}" \
              --set-secrets "INFISICAL_TOKEN=infisical-token:latest" \
              --args test
          else
            echo "Creating new Cloud Run Job..."
            gcloud run jobs create ${{ env.JOB_NAME }} \
              --image "${IMAGE_URI}" \
              --region ${{ env.GCP_REGION }} \
              --memory 4Gi \
              --cpu 2 \
              --max-retries 0 \
              --task-timeout 3600 \
              --set-env-vars "INFISICAL_PROJECT_ID=${{ env.INFISICAL_PROJECT_ID }}" \
              --set-secrets "INFISICAL_TOKEN=infisical-token:latest" \
              --args test
          fi
          
      - name: Execute Cloud Run Job
        id: execute_job
        run: |
          echo "Starting Cloud Run Job execution..."
          
          # Execute the job and capture execution name
          EXECUTION=$(gcloud run jobs execute ${{ env.JOB_NAME }} \
            --region ${{ env.GCP_REGION }} \
            --format=json)
          
          EXECUTION_NAME=$(echo "$EXECUTION" | jq -r '.metadata.name')
          echo "execution_name=$EXECUTION_NAME" >> $GITHUB_OUTPUT
          echo "Job execution started: $EXECUTION_NAME"
          
          # Wait for completion (with timeout)
          echo "Waiting for job to complete..."
          MAX_WAIT=3600  # 1 hour
          ELAPSED=0
          INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(gcloud run jobs executions describe "$EXECUTION_NAME" \
              --region ${{ env.GCP_REGION }} \
              --format='value(status.conditions[0].type)')
            
            if [ "$STATUS" = "Completed" ]; then
              echo "Job completed successfully"
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "Job failed"
              exit 1
            fi
            
            echo "Status: $STATUS, waiting..."
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "Job execution timed out"
          exit 1
          
      - name: Retrieve test results from job
        id: get_results
        if: always()
        run: |
          EXECUTION_NAME="${{ steps.execute_job.outputs.execution_name }}"
          
          echo "Fetching logs from Cloud Run Job..."
          
          # Get logs from Cloud Logging
          gcloud logging read \
            "resource.type=cloud_run_job AND resource.labels.job_name=${{ env.JOB_NAME }} AND labels.\"run.googleapis.com/execution_name\"=$EXECUTION_NAME" \
            --limit 10000 \
            --format json \
            --project ${{ env.GCP_PROJECT_ID }} > job_logs.json
          
          # Extract test results from logs
          python3 << 'PYTHON_SCRIPT'
import json
import re
import sys

try:
    with open('job_logs.json', 'r') as f:
        logs = json.load(f)
    
    # Combine all log messages
    all_logs = []
    for entry in logs:
        if 'textPayload' in entry:
            all_logs.append(entry['textPayload'])
        elif 'jsonPayload' in entry:
            if 'message' in entry['jsonPayload']:
                all_logs.append(str(entry['jsonPayload']['message']))
    
    full_log = '\n'.join(reversed(all_logs))  # Reverse to get chronological order
    
    # Look for the test summary section
    summary_match = re.search(
        r'TEST RUN COMPLETE.*?Total Passed:\s*(\d+).*?Total Failed:\s*(\d+).*?Total Skipped:\s*(\d+)',
        full_log,
        re.DOTALL
    )
    
    if summary_match:
        passed = summary_match.group(1)
        failed = summary_match.group(2)
        skipped = summary_match.group(3)
        
        print(f"Parsed results: {passed} passed, {failed} failed, {skipped} skipped")
        
        # Create result summary
        with open('test_summary.txt', 'w') as f:
            f.write(f"PASSED={passed}\n")
            f.write(f"FAILED={failed}\n")
            f.write(f"SKIPPED={skipped}\n")
        
        # Extract failed test numbers if present
        failed_nums_match = re.search(r'FAILED TEST NUMBERS.*?Test Numbers:\s*([0-9,\s]+)', full_log)
        if failed_nums_match:
            failed_nums = failed_nums_match.group(1).strip()
            with open('test_summary.txt', 'a') as f:
                f.write(f"FAILED_NUMBERS={failed_nums}\n")
        
        sys.exit(0)
    else:
        print("Could not find test summary in logs")
        sys.exit(1)
        
except Exception as e:
    print(f"Error parsing logs: {e}")
    sys.exit(1)
PYTHON_SCRIPT
          
          # Read parsed results
          if [ -f test_summary.txt ]; then
            cat test_summary.txt >> $GITHUB_OUTPUT
            cat test_summary.txt
          else
            echo "PASSED=0" >> $GITHUB_OUTPUT
            echo "FAILED=unknown" >> $GITHUB_OUTPUT
            echo "SKIPPED=0" >> $GITHUB_OUTPUT
          fi
          
      - name: Generate PR comment from Cloud Run results
        id: generate_comment
        if: always()
        run: |
          PASSED="${{ steps.get_results.outputs.PASSED || '0' }}"
          FAILED="${{ steps.get_results.outputs.FAILED || 'unknown' }}"
          SKIPPED="${{ steps.get_results.outputs.SKIPPED || '0' }}"
          FAILED_NUMS="${{ steps.get_results.outputs.FAILED_NUMBERS || '' }}"
          EXECUTION_NAME="${{ steps.execute_job.outputs.execution_name }}"
          
          # Determine status
          if [ "$FAILED" = "0" ]; then
            STATUS="PASS"
          else
            STATUS="FAIL"
          fi
          
          # Generate comment
          cat > pr_comment.md << EOF
## Test Results (Google Cloud Run) - ${STATUS}

**Execution:** \`${EXECUTION_NAME}\`
**Region:** \`${{ env.GCP_REGION }}\`

**Summary:**
- Passed: ${PASSED}
- Failed: ${FAILED}
- Skipped: ${SKIPPED}
EOF
          
          if [ -n "$FAILED_NUMS" ]; then
            echo "" >> pr_comment.md
            echo "**FAILED TEST NUMBERS:** ${FAILED_NUMS}" >> pr_comment.md
            echo "" >> pr_comment.md
            echo "To rerun specific tests:" >> pr_comment.md
            for num in ${FAILED_NUMS//,/ }; do
              echo "  \`make regression TEST_NUM=${num}\`" >> pr_comment.md
            done
          fi
          
          cat >> pr_comment.md << EOF

---

**View Details:**
- [Cloud Run Console](https://console.cloud.google.com/run/jobs/executions/details/${{ env.GCP_REGION }}/${EXECUTION_NAME}?project=${{ env.GCP_PROJECT_ID }})
- [Cloud Logs](https://console.cloud.google.com/logs/query?project=${{ env.GCP_PROJECT_ID }})

Tests executed in isolated Google Cloud environment.
EOF
          
          # Output for next step
          COMMENT_BODY=$(cat pr_comment.md)
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMENT_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Post results to PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentBody = `${{ steps.generate_comment.outputs.comment_body }}`;
            
            // Find existing comment from this workflow
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Google Cloud Run')
            );
            
            // Update or create comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new comment');
            }
            
      - name: Upload job logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cloud-run-logs-${{ github.event.pull_request.number || github.run_number }}
          path: job_logs.json
          retention-days: 30
          
      - name: Set final job status
        if: always()
        run: |
          FAILED="${{ steps.get_results.outputs.FAILED || 'unknown' }}"
          
          if [ "$FAILED" = "0" ]; then
            echo "PASS: All tests passed on Cloud Run"
            exit 0
          else
            echo "FAIL: ${FAILED} test(s) failed on Cloud Run"
            exit 1
          fi

