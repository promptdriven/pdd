full_path,file_summary,content_hash
context/commands/generate_example.py,"This Python script serves as a comprehensive usage example and documentation for the `pdd.commands.generate` module within the PDD CLI tool. It demonstrates how to programmatically invoke and utilize three primary Click commands: `generate`, `example`, and `test`. The script defines helper functions to set up an output directory and create sample prompt and code files (specifically a simple calculator module) to simulate a real workflow.

The `main` function orchestrates five specific examples: utilizing the `generate` command to create code from prompts with various options like incremental generation and environment variables; using the `example` command to produce usage examples for generated code; employing the `test` command to generate or enhance unit tests, including coverage-based improvements; invoking commands programmatically via Click context management; and using templates with variable substitution. Additionally, the file highlights that all these commands are decorated with `@track_cost` to monitor LLM API usage expenses. The script is designed to be executable, printing detailed explanations of command signatures, arguments, and expected context objects to the console.",8edf3edbed63b4ee85d1ec2b7638d37498ae85538e5967213aaa66fcb3cf5385
context/commands/connect_example.py,"This Python script serves as a usage example and test suite for the `pdd connect` command module within a Click-based CLI application. It demonstrates four key scenarios: integrating the command into a main CLI group, simulating server startup using mocked dependencies (such as `uvicorn` and `webbrowser`) to verify argument parsing without blocking execution, testing security warnings when binding to remote interfaces without authentication tokens, and overriding the default browser target with a custom frontend URL. The script utilizes `unittest.mock` to isolate the command logic from external side effects and `click.testing.CliRunner` to programmatically invoke and verify the command's behavior and output.",d2bcda4ae1e9de22d1b657c28045a0b122dc1ef22a77e4d670f41229779a6083
context/commands/analysis_example.py,"This Python script serves as a demonstration and test harness for programmatically invoking various analysis commands from the `pdd` (Prompt Driven Development) library. It specifically showcases how to use the `detect_change`, `conflicts`, `bug`, `crash`, and `trace` commands by calling their Click command callbacks directly within a Python script rather than via the command line.

The script sets up a Click `Context` object to simulate the runtime environment, injecting configuration parameters such as verbosity, model strength, and temperature. It defines a helper function, `clean_output`, to manage file cleanup and prevent overwrite prompts. The `main` function iterates through five distinct scenarios: detecting necessary prompt changes based on a description, identifying conflicts between two prompt files, generating a unit test to reproduce a bug, analyzing and fixing a crash caused by division by zero, and tracing execution flow back to a prompt. For each scenario, the script generates dummy input files (prompts, code, logs) in an output directory, executes the corresponding analysis callback, and prints the results.",01ff82910c50ec8f8cfd22f8e3b7c011f286a4b9f90e7dd5b2eb685c1f339e56
context/commands/fix_example.py,"This Python script serves as a comprehensive demonstration and documentation for the `pdd fix` command within the `pdd` package. The script illustrates how to automatically repair errors in code and unit tests using AI-driven analysis of error logs and original prompts. It begins by setting up a simulated environment, creating sample files including a calculator module with an intentional bug (missing division-by-zero handling), a corresponding unit test, and an error log.

The script defines several functions representing different usage patterns: a basic fix invocation, an iterative ""loop mode"" that verifies fixes against a specific program, an advanced mode with agentic fallback (using Claude, Gemini, or Codex) for complex errors, and options for auto-submitting successful fixes to the PDD Cloud. Additionally, it demonstrates how to track API costs via CSV output and how to invoke the command programmatically within Python code. The `main` function orchestrates the setup but leaves the actual execution of examples commented out to prevent accidental API costs, serving primarily as a reference for developers integrating the `pdd` tool.",a61a1bb14b1f146fab52d7d408d8f2c028c8dc7dea5fc7deaa03205760f826cd
context/commands/utility_example.py,"This Python script serves as a demonstration and documentation tool for the utility commands within the `pdd` package, specifically focusing on the `install_completion_cmd` and `verify` Click commands. It illustrates how to programmatically interact with these tools without executing them fully, thereby avoiding changes to the user's shell configuration or incurring API costs. The script sets up a local environment by creating a directory of dummy files—including a prompt, a buggy Python module (`calculator.py`), and a verification script—to simulate a real-world workflow for the `verify` command. It then prints detailed information to the console using the `rich` library, explaining the inputs, outputs, and command-line arguments for both utilities. The `install_completion_cmd` section explains how shell completion is installed, while the `verify` section details the iterative code fixing process using LLMs, including parameters like budget and max attempts. Additionally, the script documents the specific return value structure of the `verify` command, describing the tuple format containing results, costs, and model names. This file acts as both an executable example and a reference guide for developers integrating or using `pdd` utility commands.",fb7389c0ec837b8b6ee481e2eda04800f565fe247643f5bb9922dd1dfdab984a
context/commands/modify_example.py,"This Python script serves as a comprehensive demonstration and test suite for the `modify` module within the `pdd` CLI tool. It specifically showcases three core commands—`split`, `change`, and `update`—which are designed to manage and evolve LLM prompts and code. The script begins by establishing a local output directory structure and generating necessary sample artifacts, including prompt files (`.prompt`), source code (`.py`), and change instructions. It then executes four distinct scenarios using `Click`'s testing runner: `split`, which demonstrates breaking a large prompt into modular sub-prompts; `change` (manual mode), which modifies an existing prompt based on specific textual instructions (e.g., adding logging); `change` (batch mode), which illustrates processing multiple prompt modifications simultaneously using a CSV file; and `update`, which performs a reverse-synchronization where a prompt file is updated to reflect manual edits made to the corresponding source code. The script is self-contained, handling file creation, command execution, and output verification.",35b98245915a4e4fe341affaa67da6b9e4a61a5f1c7a9f0d1fba042a3c280dc1
context/commands/auth_example.py,"This Python script serves as an integration example for the 'auth' command group within a CLI tool named PDD. It sets up the execution environment by adding the project root to `sys.path` to ensure internal modules can be imported correctly. The script attempts to import `auth_group` from `pdd.commands.auth` and registers it under a main Click group named `cli`. 

Instead of executing a specific command logic directly, the script is designed to demonstrate the structure and availability of authentication commands. When run as the main program, it prints an introductory message and simulates running `pdd auth --help` to display the help output for the registered authentication commands. It concludes by printing several usage examples to the console, showing users how to perform actions such as interactive login, headless login for CI environments, checking authentication status, retrieving tokens, and logging out. The primary purpose is to verify that the authentication subcommands are correctly wired into the main CLI structure.",d1e77e2ab5a5b6f3c400a8a68a73bb633f6d45e39dd4a90306dcc18c729d9000
context/commands/maintenance_example.py,"This Python script serves as a comprehensive example demonstrating the usage of maintenance commands within the `pdd` package's CLI framework. It showcases three primary Click commands: `sync` (for synchronizing prompts with code and tests), `auto-deps` (for analyzing and injecting dependencies into prompt files), and `setup` (for running an interactive setup utility). The script includes helper functions to create a mock project environment with sample prompt and code files. It then defines separate functions (`example_sync_command`, `example_auto_deps_command`, `example_setup_command`) that utilize `unittest.mock` to simulate the execution of these commands without making actual LLM calls or system modifications. Additionally, it includes an example of how to invoke these commands programmatically, bypassing the CLI parsing while maintaining the Click context.",f347251582821c4347664f674fdd6d5549bb14ba1d0e8bc428cffb9abedbfed3
context/commands/templates_example.py,"This Python script serves as a demonstration and documentation for the `pdd.commands.templates` module, specifically showcasing the CLI commands used to manage PDD templates. It utilizes the `click.testing.CliRunner` to programmatically invoke and display the output of three primary subcommands: `list`, `show`, and `copy`. The script defines separate functions for each operation: `example_list_templates` illustrates how to list available templates with options for JSON formatting and tag filtering; `example_show_template` demonstrates how to retrieve detailed metadata, variable definitions, and usage examples for a specific template; and `example_copy_template` shows how to duplicate a template file to a local destination directory. The `main` function orchestrates these examples, providing context on the purpose of the templates command group, which is designed to facilitate the discovery, inspection, and reuse of prompt templates within the PDD framework.",017d7a9cbdec60dd67cee662f3b21a68638137cd086fb335ef92889e1d91b09a
context/commands/misc_example.py,"This Python script serves as a comprehensive example and test suite for the `pdd.commands.misc.preprocess` module, specifically demonstrating the functionality of the `preprocess` Click command. The script illustrates how to prepare prompt files for Large Language Models (LLMs) by handling directives such as file includes, comments, shell commands, and web scraping locally without API calls. It defines a setup function to generate sample prompt and text files, followed by five distinct example functions that simulate command-line execution using `CliRunner`. These examples cover basic preprocessing, XML delimiter insertion, curly bracket doubling (with exclusion logic for template variables), recursive file inclusion, and a combination of these options. The script concludes with a main execution block that runs all examples sequentially, printing the results and exit codes to the console, thereby verifying the preprocessor's capabilities in handling various formatting and content integration tasks.",7d7985d21dd7b962257856cb92d13e26c016bc09ce14aaac4c68baaead97dc4b
context/commands/__init___example.py,"This Python script serves as a demonstration and usage example for the `register_commands` module within a project named PDD (Python Development Driver). The file illustrates how to set up a Click-based Command Line Interface (CLI) by importing and utilizing the `register_commands` function to attach various subcommands to a main `click.Group`. It defines a primary CLI entry point (`cli`) and a secondary custom example (`custom_cli`), showing that the registration process works on any Click group. The script documents the specific categories of commands available, including Generation, Fixing, Modification, Maintenance, Analysis, Miscellaneous, Utility, and Templates. When executed directly, the script prints a formatted list of these registered commands organized by category, displaying their help text summaries, and provides usage examples for invoking the CLI tools. Essentially, it acts as both a functional test of the command registration logic and a documentation reference for the available CLI capabilities.",cc6e0de7d94b1dddda35d9c8ecb800710263d928191f1d4cb2400bae36c31cb4
context/commands/sessions_example.py,"This file contains a Python test/demonstration script designed to verify the functionality of a CLI module, specifically the `pdd.commands.sessions` component. The script primarily focuses on mocking external dependencies to allow standalone execution without a real backend connection. It mocks several modules within the `pdd` namespace, including `core.cloud`, `remote_session`, and `utils`, replacing them with `unittest.mock.MagicMock` objects. Key mocked components include `CloudConfig` for handling JWT tokens and `RemoteSessionManager` for retrieving session data. The script defines a `DummySession` class and populates a fake dataset containing sample session information (IDs, project names, URLs, statuses). It implements asynchronous mock functions (`mock_list_sessions` and `mock_get_session`) to simulate API responses. The `run_example` function utilizes `click.testing.CliRunner` to programmatically invoke CLI commands (`list` and `info`) and print the results to the console using the `rich` library. This setup allows developers to visualize the output of commands like `sessions list` (in both table and JSON formats) and `sessions info <id>`, as well as handle error cases like missing sessions, ensuring the CLI interface behaves correctly under controlled conditions.",b4d9f8c45f3bf02f9e531bd411937872dfc77705a225a03f56df86c197da13bf
