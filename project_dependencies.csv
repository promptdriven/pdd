full_path,file_summary,content_hash
context/commands/generate_example.py,"This Python script serves as a comprehensive usage example and documentation for the `pdd.commands.generate` module within the PDD CLI tool. It demonstrates how to programmatically invoke and utilize three primary Click commands: `generate`, `example`, and `test`. The script defines helper functions to set up an output directory and create sample prompt and code files (specifically a simple calculator module) to simulate a real workflow.

The `main` function orchestrates five specific examples: utilizing the `generate` command to create code from prompts with various options like incremental generation and environment variables; using the `example` command to produce usage examples for generated code; employing the `test` command to generate or enhance unit tests, including coverage-based improvements; invoking commands programmatically via Click context management; and using templates with variable substitution. Additionally, the file highlights that all these commands are decorated with `@track_cost` to monitor LLM API usage expenses. The script is designed to be executable, printing detailed explanations of command signatures, arguments, and expected context objects to the console.",8edf3edbed63b4ee85d1ec2b7638d37498ae85538e5967213aaa66fcb3cf5385
context/commands/analysis_example.py,"This Python script serves as a demonstration of how to programmatically invoke analysis commands from the `pdd` library, specifically `detect_change`, `conflicts`, `bug`, `crash`, and `trace`. Rather than using the command-line interface, the script manually constructs a `click.Context` to inject necessary global configuration settings—such as verbosity, model strength, and cost tracking—required by the underlying Click-based commands.

The script iterates through five distinct scenarios, generating temporary dummy files (prompts, code snippets, and error logs) in a local ""output"" directory to simulate inputs. These scenarios include: detecting if prompts need updates based on a change request, identifying contradictions between two files, generating a unit test to reproduce a logic bug, analyzing and fixing a crash caused by division by zero, and tracing code execution back to prompt instructions. A helper function, `clean_output`, is used throughout to manage file cleanup and prevent overwrite errors.",3aee1362fca897c88ba026f47eb45cac6d9bc5b0ed57ebfa66b32d5935f606ea
context/commands/fix_example.py,"This Python script serves as a comprehensive demonstration and documentation for the `pdd fix` command within the `pdd` package. The script illustrates how to automatically repair errors in code and unit tests using AI-driven analysis of error logs and original prompts. It begins by setting up a simulated environment, creating sample files including a calculator module with an intentional bug (missing division-by-zero handling), a corresponding unit test, and an error log.

The script defines several functions representing different usage patterns: a basic fix invocation, an iterative ""loop mode"" that verifies fixes against a specific program, an advanced mode with agentic fallback (using Claude, Gemini, or Codex) for complex errors, and options for auto-submitting successful fixes to the PDD Cloud. Additionally, it demonstrates how to track API costs via CSV output and how to invoke the command programmatically within Python code. The `main` function orchestrates the setup but leaves the actual execution of examples commented out to prevent accidental API costs, serving primarily as a reference for developers integrating the `pdd` tool.",a61a1bb14b1f146fab52d7d408d8f2c028c8dc7dea5fc7deaa03205760f826cd
context/commands/utility_example.py,"This Python script serves as a demonstration and documentation tool for the utility commands within the `pdd` package, specifically focusing on the `install_completion_cmd` and `verify` Click commands. It illustrates how to programmatically interact with these tools without executing them fully, thereby avoiding changes to the user's shell configuration or incurring API costs. The script sets up a local environment by creating a directory of dummy files—including a prompt, a buggy Python module (`calculator.py`), and a verification script—to simulate a real-world workflow for the `verify` command. It then prints detailed information to the console using the `rich` library, explaining the inputs, outputs, and command-line arguments for both utilities. The `install_completion_cmd` section explains how shell completion is installed, while the `verify` section details the iterative code fixing process using LLMs, including parameters like budget and max attempts. Additionally, the script documents the specific return value structure of the `verify` command, describing the tuple format containing results, costs, and model names. This file acts as both an executable example and a reference guide for developers integrating or using `pdd` utility commands.",fb7389c0ec837b8b6ee481e2eda04800f565fe247643f5bb9922dd1dfdab984a
context/commands/modify_example.py,"This Python script serves as a comprehensive demonstration and test harness for the `modify` module of the `pdd` CLI tool. It illustrates how to use three primary commands: `split`, `change`, and `update`, which are designed to manage and refactor prompt files and their associated code. The script includes helper functions to set up a local directory structure (`./output/`) and generate necessary sample files, such as large prompts for splitting, code files for updating, and CSVs for batch processing. It then uses `click.testing.CliRunner` to programmatically execute these CLI commands, simulating real-world usage scenarios like splitting a data pipeline prompt, adding logging via change instructions, and updating a prompt based on modified code. The script also highlights the use of the `@track_cost` decorator for monitoring LLM usage costs associated with these operations.",fc27573c54b630f4a61a0a04f3f4ade8feb5c322e77101ec9c73a5aeb962407a
context/commands/maintenance_example.py,"This Python script serves as a comprehensive example demonstrating the usage of maintenance commands within the `pdd` package's CLI framework. It showcases three primary Click commands: `sync` (for synchronizing prompts with code and tests), `auto-deps` (for analyzing and injecting dependencies into prompt files), and `setup` (for running an interactive setup utility). The script includes helper functions to create a mock project environment with sample prompt and code files. It then defines separate functions (`example_sync_command`, `example_auto_deps_command`, `example_setup_command`) that utilize `unittest.mock` to simulate the execution of these commands without making actual LLM calls or system modifications. Additionally, it includes an example of how to invoke these commands programmatically, bypassing the CLI parsing while maintaining the Click context.",f347251582821c4347664f674fdd6d5549bb14ba1d0e8bc428cffb9abedbfed3
context/commands/templates_example.py,"This Python script serves as a demonstration and documentation for the `pdd.commands.templates` module, specifically showcasing the CLI commands used to manage PDD templates. It utilizes the `click.testing.CliRunner` to programmatically invoke and display the output of three primary subcommands: `list`, `show`, and `copy`. The script defines separate functions for each operation: `example_list_templates` illustrates how to list available templates with options for JSON formatting and tag filtering; `example_show_template` demonstrates how to retrieve detailed metadata, variable definitions, and usage examples for a specific template; and `example_copy_template` shows how to duplicate a template file to a local destination directory. The `main` function orchestrates these examples, providing context on the purpose of the templates command group, which is designed to facilitate the discovery, inspection, and reuse of prompt templates within the PDD framework.",017d7a9cbdec60dd67cee662f3b21a68638137cd086fb335ef92889e1d91b09a
context/commands/misc_example.py,"This Python script serves as a comprehensive example and test suite for the `pdd.commands.misc.preprocess` module, specifically demonstrating the functionality of the `preprocess` Click command. The script illustrates how to prepare prompt files for Large Language Models (LLMs) by handling directives such as file includes, comments, shell commands, and web scraping locally without API calls. It defines a setup function to generate sample prompt and text files, followed by five distinct example functions that simulate command-line execution using `CliRunner`. These examples cover basic preprocessing, XML delimiter insertion, curly bracket doubling (with exclusion logic for template variables), recursive file inclusion, and a combination of these options. The script concludes with a main execution block that runs all examples sequentially, printing the results and exit codes to the console, thereby verifying the preprocessor's capabilities in handling various formatting and content integration tasks.",7d7985d21dd7b962257856cb92d13e26c016bc09ce14aaac4c68baaead97dc4b
context/commands/__init___example.py,"This Python script serves as a demonstration and usage example for the `register_commands` module within a project named PDD (Python Development Driver). The file illustrates how to set up a Click-based Command Line Interface (CLI) by importing and utilizing the `register_commands` function to attach various subcommands to a main `click.Group`. It defines a primary CLI entry point (`cli`) and a secondary custom example (`custom_cli`), showing that the registration process works on any Click group. The script documents the specific categories of commands available, including Generation, Fixing, Modification, Maintenance, Analysis, Miscellaneous, Utility, and Templates. When executed directly, the script prints a formatted list of these registered commands organized by category, displaying their help text summaries, and provides usage examples for invoking the CLI tools. Essentially, it acts as both a functional test of the command registration logic and a documentation reference for the available CLI capabilities.",cc6e0de7d94b1dddda35d9c8ecb800710263d928191f1d4cb2400bae36c31cb4
