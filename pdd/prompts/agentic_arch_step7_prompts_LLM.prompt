<pdd-reason>Generates prompt files for all modules defined in architecture.json, placing them in the correct directories based on .pddrc configuration.</pdd-reason>
<pdd-interface>
{{
  "type": "module",
  "module": {{
    "functions": [
      {{"name": "generate_prompts", "signature": "(architecture_json: str, pddrc_content: str)", "returns": "str (list of generated prompt files)"}}
    ]
  }}
}}
</pdd-interface>
<pdd-dependency>agentic_arch_step6_generate_LLM.prompt</pdd-dependency>
% You are an expert prompt writer for PDD (Prompt-Driven Development). Your task is to generate prompt files for all modules defined in architecture.json.

% Context

You are working on step 7 of the agentic architecture workflow. Step 6 generated architecture.json, .pddrc, and scaffolding files. Now generate the actual prompt files that will be used by `pdd sync` to generate code.

% Inputs

- GitHub Issue URL: {issue_url}
- Repository: {repo_owner}/{repo_name}
- Issue Number: {issue_number}

% Architecture (validated)
<architecture_json>
{step6_output}
</architecture_json>

% PDD Configuration
<pddrc>
{pddrc_content}
</pddrc>

% Prompt Generation Template Reference
<prompt_template>
<include>pdd/templates/generic/generate_prompt.prompt</include>
</prompt_template>

% Your Task

For EACH module in architecture.json, generate a prompt file following these steps:

1. **Determine the prompts directory:**
   - Find which context in .pddrc matches this module (using `paths` patterns)
   - Use that context's `prompts_dir` (e.g., "prompts/api/", "prompts/frontend/")
   - If no context matches, use "prompts/" as default

2. **Generate the prompt content:**
   Each prompt file must have this structure:

   ```
   [Role paragraph - describe the module's responsibility within the system]

   Requirements
   1. [Functional requirement based on architecture description]
   2. [Interface/contract requirement]
   3. [Error handling requirement]
   4. [Validation requirement]
   5. [Performance/security requirements as applicable]

   Dependencies
   <dependency_name>
     <include>examples/{dependency_basename}_example.{ext}</include>
   </dependency_name>
   [Include all dependencies from architecture.json]

   Prompt Dependencies:
   - {dependency_filename} - {brief description}
   [List all prompt dependencies]

   Instructions
   - [Specific implementation guidance]
   - [Input/output specifications]
   - [Edge cases to handle]
   - [Testing considerations]

   Deliverable
   - [Expected code artifacts]
   - [Entry points/exports]
   - [Integration requirements]

   Implementation assumptions (explicit)
   - [Any assumptions made about the environment]
   - [Dependencies on other modules]
   ```

3. **Write the prompt file to disk:**
   - Path: {prompts_dir}/{filename}
   - Example: `prompts/api/api_courses_route_TypeScript.prompt`

4. **Ensure prompt content is rich and contextual:**
   - Use the `reason` field to understand why this module exists
   - Use the `description` field for architectural details
   - Use the `interface` field to understand the module's contract
   - Use `context_urls` to reference external documentation
   - Use `dependencies` to understand what this module depends on

% Framework-Specific Considerations

**For Next.js App Router modules:**
- API routes (route.ts): Include REST endpoint specifications, request/response shapes, error handling
- Pages (page.tsx): Include route params, data sources, client/server component distinction
- Layouts (layout.tsx): Include children rendering, shared state, navigation context
- Middleware (middleware.ts): Include request interception, auth checks, redirects

**For Python backend modules:**
- Include type hints requirements
- Specify Pydantic models for validation
- Include FastAPI/Flask route decorators
- Specify database session handling

**For React components:**
- Include props interface
- Specify state management approach
- Include accessibility requirements
- Specify styling approach (Tailwind, CSS modules, etc.)

% Output

1. **Write ALL prompt files to their correct directories**
   Create the directory structure if it doesn't exist (e.g., `prompts/api/`, `prompts/frontend/`)

2. **Post summary to GitHub**
   Use `gh issue comment` to post a summary to issue #{issue_number}:

```
gh issue comment {issue_number} --repo {repo_owner}/{repo_name} --body "..."
```

```markdown
## Step 7: Prompts Generated

**Status:** Prompts Complete

### Generated Prompts
| Module | Prompt File | Directory |
|--------|-------------|-----------|
| [basename] | [filename] | [prompts_dir] |

### Summary
- Total prompts generated: [N]
- Directories created: [list or "None"]
- Contexts used: [list of contexts]

### Next Steps
Run `pdd sync <basename>` to generate code for any module, for example:
- `pdd sync api_courses_route` → generates `app/api/courses/route.ts`
- `pdd sync dashboard_page` → generates `app/dashboard/page.tsx`

---
*Proceeding to Step 8: Validation*
```

3. **Report ALL files created**
   Output on its own line at the end:
   `FILES_CREATED: prompts/api/api_courses_route_TypeScript.prompt, prompts/frontend/dashboard_page_TypeScriptReact.prompt, ...`

% Important

- Write each prompt file directly to disk at the correct path
- Create directories as needed (e.g., `mkdir -p prompts/api`)
- Each prompt should be self-contained with enough context for code generation
- Use <include> tags to reference dependency examples (these will be resolved by pdd sync)
- Use <web> tags for context_urls to enable fetching external documentation
- Include the module's full context (reason, description, interface) in the prompt
- Ensure prompts follow PDD conventions for the language/framework
- Always post your findings as a GitHub comment
- Always output `FILES_CREATED:` with the complete list of ALL prompt files created
