% You are an expert Python engineer. Your goal is to write the pdd/agentic_fix.py module, matching the original implementation exactly to ensure compatibility with the existing test suite.

% Role & Scope
A module that provides a robust, multi-agent, two-pass fallback mechanism for fixing code. It orchestrates local CLI-based agents to repair code based on a detailed problem description.

% Requirements
- The file must start with from __future__ import annotations.
- All functions must be fully type-hinted.
- Use rich.console.Console for all printing (initialise the Console and use it consistently for all output).
- Preserve all public names and function signatures exactly; tests import symbols by name.

% Instructions

### Module Imports
- Import all necessary modules: os, re, shutil, subprocess, difflib, pathlib, typing, rich.console.
- Perform the following specific internal imports:
  - from .get_language import get_language
  - from .llm_invoke import _load_model_data
  - from .load_prompt_template import load_prompt_template
  - from .agentic_langtest import default_verify_cmd_for

### Module Constants and Globals
- Define AGENT_PROVIDER_PREFERENCE as ["anthropic", "google", "openai"].
- Implement the exact logging level detection logic based on PDD_AGENTIC_LOGLEVEL and PYTEST_CURRENT_TEST:
  - _env_level = os.getenv("PDD_AGENTIC_LOGLEVEL")
  - if _env_level is None and os.getenv("PYTEST_CURRENT_TEST"): _env_level = "quiet"
  - _LOGLEVEL = (_env_level or "normal").strip().lower()
  - _IS_QUIET = _LOGLEVEL == "quiet"
  - _IS_VERBOSE = _LOGLEVEL == "verbose"
- Define all environment-tunable constants and regex constants exactly as in the correct file:
  - _AGENT_COST_PER_CALL = float(os.getenv("PDD_AGENTIC_COST_PER_CALL", "0.02"))
  - _AGENT_CALL_TIMEOUT = int(os.getenv("PDD_AGENTIC_TIMEOUT", "240"))
  - _VERIFY_TIMEOUT = int(os.getenv("PDD_AGENTIC_VERIFY_TIMEOUT", "120"))
  - _MAX_LOG_LINES = int(os.getenv("PDD_AGENTIC_MAX_LOG_LINES", "200"))
  - _AGENT_TESTCMD_ALLOWED = os.getenv("PDD_AGENTIC_AGENT_TESTCMD", "1") != "0"
  - _COMMON_FIXED_SUFFIXES = ("_fixed", ".fixed", "-fixed")

### Helper Functions (implement EXACT behavior & signatures; fully type-hinted)
- _print(msg: str, *, force: bool = False) -> None
  - Rich print via console; suppressed if _IS_QUIET unless force=True.
- _info(msg: str) -> None
  - Calls _print.
- _always(msg: str) -> None
  - Calls _print (do not force).
- _verbose(msg: str) -> None
  - Only prints when _IS_VERBOSE is True.
- _begin_marker(path: Path) -> str  => "<<<BEGIN_FILE:{path}>>>"
- _end_marker(path: Path) -> str    => "<<<END_FILE:{path}>>>"
- get_agent_command(provider: str, instruction_file: Path) -> List[str]
  - "openai" -> ["codex", "exec", "--skip-git-repo-check"]; "anthropic"/"google" -> []; unknown -> [].
- find_llm_csv_path() -> Optional[Path]
  - Return the first existing among (in order): ~/.pdd/llm_model.csv, ~/.llm/llm_model.csv, ./.pdd/llm_model.csv; else None.
- _print_head(label: str, text: str, max_lines: int = _MAX_LOG_LINES) -> None
  - Verbose-only: print first max_lines and note truncation.
- _print_diff(old: str, new: str, path: Path) -> None
  - Verbose-only unified diff; if empty, print "[yellow]No diff in code file after this agent attempt.[/yellow]".
- _normalize_code_text(body: str) -> str
  - Remove one leading newline if present; ensure exactly one trailing newline.

- _extract_files_from_output(*blobs: str) -> Dict[str, str]
  - Regex (DOTALL) MUST be exactly:
    r"<<<BEGIN_FILE:(.*?)>>>(.*?)<<<END_FILE:\1>>>"
  - Return {emitted_path: content}.

- _extract_testcmd(*blobs: str) -> Optional[str]
  - Detect one block between <<<BEGIN_TESTCMD>>> and <<<END_TESTCMD>>>.

- _extract_corrected_from_output(stdout: str, stderr: str, code_path: Path) -> Optional[str]
  - **CRITICAL FIX (from latest failures): DO NOT call .realpath() on a Path.**
  - Match the LAST block that targets the primary code file, considering ONLY these path forms:
    • str(code_path.resolve())
    • os.path.relpath(code_path.resolve(), Path.cwd())
    • code_path.name
    • (Optional string-only addition permitted) os.path.realpath(str(code_path))
  - Ignore any block containing the placeholder "FULL CORRECTED FILE CONTENT HERE" (case-insensitive).
  - Return the body, or None if not found.

- _extract_python_code_block(*blobs: str) -> Optional[str]
  - Fallback for Gemini: last fenced block from ``` or ```python; ensure trailing newline.

- _sanitized_env_common() -> dict
  - TERM=dumb, CI=1, NO_COLOR=1, CLICOLOR=0, CLICOLOR_FORCE=0, FORCE_COLOR=0, SHELL=/bin/sh, COLUMNS=80 (if unset), LINES=40 (if unset).

- _sanitized_env_for_openai() -> dict
  - Start from common; remove COMP_* and completion vars ("BASH_COMPLETION", "BASH_COMPLETION_COMPAT_DIR", "BASH_VERSION", "BASH", "ZDOTDIR", "ZSH_NAME", "ZSH_VERSION"); set DISABLE_AUTO_COMPLETE=1, OPENAI_CLI_NO_TTY=1, OPENAI_CLI_NO_COLOR=1.

- _run_cli(cmd: List[str], cwd: Path, timeout: int) -> subprocess.CompletedProcess
  - Generic runner; capture stdout/stderr; no exception on non-zero.

- _run_openai_variants(prompt_text: str, cwd: Path, total_timeout: int, label: str) -> subprocess.CompletedProcess
  - Prepend a wrapper that instructs: ONLY output corrected content wrapped by our markers, no commentary.
  - Try in order: ["codex","exec",full], ["codex","exec","--skip-git-repo-check",full], ["codex","exec","--skip-git-repo-check","--sandbox","read-only",full].
  - Per-attempt time = max(12, min(45, total_timeout // 2)).
  - Return the first result that yields any output or has rc==0. Log timeouts in yellow.
- _run_anthropic_variants(...) and _run_google_variants(...)
  - Similar semantics; single attempt: ["claude","-p",full] and ["gemini","-p",full] respectively (use sanitized envs).

- _run_testcmd(cmd: str, cwd: Path) -> bool
  - Run via ["bash","-lc",cmd]; verbose preview stdout/stderr; return rc==0.

- _verify_and_log(unit_test_file: str, cwd: Path, *, verify_cmd: Optional[str], enabled: bool) -> bool
  - If not enabled: return True.
  - If verify_cmd present: substitute {test} (abs path) and {cwd} (project root) then call _run_testcmd.
  - Else run: [os.sys.executable, "-m", "pytest", unit_test_file, "-q"].
  - Verbose preview stdout/stderr. Return rc==0.

- _safe_is_subpath(child: Path, parent: Path) -> bool
  - True iff child.resolve() is under parent.resolve().

- _strip_common_suffixes(name: str) -> str
  - Remove one of _COMMON_FIXED_SUFFIXES before extension; return base+ext.

- _find_existing_by_basename(project_root: Path, basename: str) -> Optional[Path]
  - First rglob match resolved, else None.

- _normalize_target_path(emitted_path: str, project_root: Path, primary_code_path: Path, allow_new: bool) -> Optional[Path]
  - Resolve to absolute inside project root; map emitted basename to primary file (incl. *_fixed variants); if not allow_new and path doesn’t exist, skip.

- _apply_file_map(file_map: Dict[str, str], project_root: Path, primary_code_path: Path, allow_new: bool) -> List[Path]
  - Normalize, write, mkdir parents, show diff (verbose); return list of written Paths.

- _post_apply_verify_or_testcmd(provider: str, unit_test_file: str, cwd: Path, *, verify_cmd: Optional[str], verify_enabled: bool, stdout: str, stderr: str) -> bool
  - Run standard verification; if it fails (or disabled) and _AGENT_TESTCMD_ALLOWED, try TESTCMD. Return True on any pass.

- _try_harvest_then_verify(provider: str, code_path: Path, unit_test_file: str, code_snapshot: str, prompt_content: str, test_content: str, error_content: str, cwd: Path, *, verify_cmd: Optional[str], verify_enabled: bool) -> bool
  - Load "agentic_fix_harvest_only_LLM".
  - Format with EXACT keys listed in Prompt Formatting Logic.
  - Write "agentic_fix_harvest.txt".
  - Run provider variant with shorter timeout (use max(60, _AGENT_CALL_TIMEOUT // 3)).
  - Prefer multi-file; else single-file; for Google allow fenced-code fallback.
  - After applying, call _post_apply_verify_or_testcmd.
  - Delete the temp file even on failure. Return bool.

### Main Entry Point (EXACT SIGNATURE)
def run_agentic_fix(prompt_file: str, code_file: str, unit_test_file: str, error_log_file: str) -> Tuple[bool, str, float, str]:

Agent discovery logic (MATCH TEST EXPECTATIONS; **do not touch `model_id`**):
1) csv_path = find_llm_csv_path().
2) If not found, RETURN EXACTLY: (False, "Could not find llm_models.csv in ~/.pdd/ or ~/.llm/", est_cost, used_model).
3) model_df = _load_model_data(csv_path)  # pass the path argument.
4) Initialize: available_agents: List[str] = [], present_keys: List[str] = [], seen = set().
5) For each provider in AGENT_PROVIDER_PREFERENCE:
   - provider_df = model_df[model_df["provider"].str.lower() == provider]; continue if empty.
   - api_key_name = provider_df["api_key"].iloc[0]    # CRITICAL exact access
   - found = os.getenv(api_key_name) or (os.getenv("GEMINI_API_KEY") if provider == "google" else None)
   - If found and provider not in seen:
       present_keys.append(api_key_name if provider != "google" or os.getenv(api_key_name) else "GEMINI_API_KEY")
       available_agents.append(provider)   # append PROVIDER NAME, not model IDs
       seen.add(provider)
6) If available_agents is empty, RETURN EXACTLY: (False, "No configured agent API keys found in environment.", est_cost, used_model).

Inputs & preflight:
- Print banner (bold yellow).
- cwd = Path.cwd(); print cyan line.
- Read prompt_content, code_path (resolved), orig_code, test_content, error_content.
- If error_content.strip() == "":
  - lang = get_language(code_path.suffix)
  - pre_cmd = os.getenv("PDD_AGENTIC_VERIFY_CMD") or default_verify_cmd_for(lang, unit_test_file)
  - If pre_cmd: substitute {test} and {cwd}, run via bash -lc; else run [os.sys.executable, "-m", "pytest", unit_test_file, "-q"].
  - error_content = stdout + "\n" + stderr; write back to error_log_file. Verbose preview stdout/stderr.

Verification policy (exact):
- env_verify = os.getenv("PDD_AGENTIC_VERIFY"); verify_force = (os.getenv("PDD_AGENTIC_VERIFY_FORCE") == "1").
- verify_cmd = os.getenv("PDD_AGENTIC_VERIFY_CMD") or default_verify_cmd_for(get_language(code_path.suffix), unit_test_file).
- verify_enabled = True if verify_force or verify_cmd else (False if (env_verify and env_verify.lower()=="auto") else (env_verify != "0" if env_verify is not None else True)).

Primary instruction:
- primary_prompt_template = load_prompt_template("agentic_fix_primary_LLM"); if falsy, RETURN EXACT tuple: (False, "Failed to load primary agent prompt template.", est_cost, used_model).
- Format with keys: code_abs, test_abs, begin, end, prompt_content, code_content, test_content, error_content, verify_cmd.
- Write "agentic_fix_instructions.txt". Verbose preview head.

Two-pass loop (PER PROVIDER; **call the public alias** and set used_model as tests expect):
- allow_new = True.
- For each provider in available_agents (order preserved):
  - used_model = f"agentic-{provider}"     # CRITICAL string used by tests
  - binary = {"anthropic":"claude", "google":"gemini", "openai":"codex"}[provider]
  - If shutil.which(binary) is falsy: log yellow skip and continue.
  - Pass 1 (harvest-only): est_cost += _AGENT_COST_PER_CALL; call **public alias** (CRITICAL):
        if try_harvest_then_verify(provider, code_path, unit_test_file, orig_code, prompt_content, test_content, error_content, cwd, verify_cmd=verify_cmd, verify_enabled=verify_enabled):
            delete instruction file; return (True, f"Agentic fix successful with {provider.capitalize()}.", est_cost, used_model)
  - Pass 2 (primary): est_cost += _AGENT_COST_PER_CALL; run provider variant with primary instruction and apply as follows:
        * Prefer multi-file via _extract_files_from_output + _apply_file_map.
        * Else single-file via _extract_corrected_from_output.
        * If provider == "google" and no markers found, allow fenced-code fallback.
        * Show diff (verbose).
        * If (returncode == 0) OR (any file changed) OR (multi-file emitted): run _post_apply_verify_or_testcmd; on pass, print success and return tuple as above.
  - Update orig_code = current file text before trying next provider.

After loop:
- Clean up temp file if present and return (False, "All agents failed to produce a passing fix (no local fallback).", est_cost, used_model).

Exceptions:
- FileNotFoundError -> print bold red; return (False, f"A required file or command was not found: {e}. Is the agent CLI installed and in your PATH?", 0.0, "agentic-cli").
- Generic Exception -> print bold red; return (False, str(e), 0.0, "agentic-cli").

### Prompt Formatting Logic (BOTH templates must receive these keys)
- code_abs, test_abs, begin, end, prompt_content, code_content, test_content, error_content, verify_cmd.

### Provider Nuances
- OpenAI variants as listed; add wrapper instructing “only markers, no commentary”.
- Anthropic & Google single-run variants with same wrapper and shorter budgets for harvest path.

### File Application Rules
- Enforce project-root safety (_safe_is_subpath).
- Map *_fixed basenames back to the primary target when appropriate.
- Prefer multi-file application; else single-file; Google fenced-code fallback allowed.
- After write, always normalize content with _normalize_code_text and show unified diff in verbose.

### Logging
- Cyan: progress lines. Yellow: warnings/timeouts/skips. Bold green: success messages.
- _print_head truncates to _MAX_LOG_LINES in verbose mode.

% Test Compatibility & Public Alias (CRITICAL)
- At the very end of the module, after all other code, include this exact alias so tests can monkeypatch it:
try_harvest_then_verify = _try_harvest_then_verify

% Dependencies
<pdd>This module relies on several internal helper modules.</pdd>
<module_dependencies>
  <agentic_langtest_example>
    <include>context/agentic_langtest_example.py</include>
  </agentic_langtest_example>
  <get_language_example>
    <include>context/get_language_example.py</include>
  </get_language_example>
  <load_prompt_template_example>
    <include>context/load_prompt_template_example.py</include>
  </load_prompt_template_example>
</module_dependencies>

% Deliverables
- Code: pdd/agentic_fix.py containing the exact implementation as specified.
- **Test Compatibility Aliases**: At the very end of the file, after all other code, you **must** include the following line to create a public alias for testing:
try_harvest_then_verify = _try_harvest_then_verify
