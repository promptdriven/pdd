Unified Architecture Template (JSON)
Purpose: Produce an architecture JSON that enumerates prompt files to generate
across multiple tech stacks using a single template. Drive behavior with -e vars.

Recommended -e variables (examples):
  - STACK=nextjs|python|fastapi|flask|django|node|go (choose one; default: infer from files)
  - APP_NAME=MyApp (optional)
  - ROUTES='["/","/about","/dashboard"]' (optional, for frontend stacks)
  - API_STYLE=rest|graphql (optional, for backend stacks)

Notes:
- Includes below pull common docs and files if present. Missing files are OK—ignore
  any "[File not found: ...]" placeholders.
- Only output JSON; do not include commentary or markdown.
- Always include core keys (reason, description, dependencies, priority, filename).
- Conditionally include stack-specific keys:
    * nextjs/frontend: route
    * python/backend: signatures (function/method signatures), endpoints (if API)
- Include only keys that apply to the chosen stack; omit others (no nulls).

Context banner (variable hints)
Stack: ${STACK}
App: ${APP_NAME}
Routes: ${ROUTES}
API Style: ${API_STYLE}

Project documentation (variable-driven only; no hardcoded paths)
Optional: pass a primary PRD/spec via -e PRD_FILE=path/to/spec.md
<prd_var><include>${PRD_FILE}</include></prd_var>
Optional: pass a list of additional docs via -e DOC_FILES='docs/a.md,docs/b.md' (comma/newline-separated)
<include-many>${DOC_FILES}</include-many>

Optional: pass a list of source files to include via -e INCLUDE_FILES
Example: -e INCLUDE_FILES='frontend/app/layout.tsx,frontend/app/page.tsx,src/api.py'
<include-many>${INCLUDE_FILES}</include-many>

Optional: auto-discovery helper using patterns. You can pass a comma-separated list
of filenames (not paths) and an optional scan root. The results will be embedded
using backtick includes and picked up on the second preprocessing pass.
Example: -e SCAN_PATTERNS='layout.tsx,page.tsx,globals.css,tailwind.config.js' -e SCAN_ROOT=.
<shell>
ROOT="${SCAN_ROOT}"
PATS="${SCAN_PATTERNS}"
if [ -n "$PATS" ]; then
  OIFS="$IFS"; IFS=','
  for p in $PATS; do
    IFS="$OIFS"
    # Limit to a reasonable number to keep token usage under control
    find "${ROOT:-.}" -type f -name "$p" 2>/dev/null | head -n 10 |
    while IFS= read -r f; do printf '```<%s>```\n' "$f"; done
    OIFS="$IFS"; IFS=','
  done
  IFS="$OIFS"
fi
</shell>

You may also include backend files via INCLUDE_FILES or SCAN_PATTERNS (e.g., app.py, main.py, api.py)

OUTPUT SPEC
Create a JSON array where each element corresponds to one prompt file to create.
Core keys per element (always include):
  - reason (string): Why this prompt and resulting file are needed.
  - description (string): Multi‑paragraph details: purpose, implementation plan, logic paths,
                          edge cases, validation, and error handling.
  - dependencies (array of strings): Filenames this file depends on.
  - priority (integer): 1 = highest priority.
  - filename (string): Prompt filename following PDD conventions
      * Examples: page_tsx.prompt → page.tsx, layout_tsx.prompt → layout.tsx,
                 global_css.prompt → global.css, api_python.prompt → api.py
  - tags (array of strings, optional): e.g., ["frontend","nextjs"], ["backend","api"].

Interface (typed, include only what applies; omit unrelated fields):
  - interface: {
      type: "component" | "page" | "module" | "api" | "graphql" | "cli" | "job" | "message" | "config",
      component?: {
        props: [{ name, type, required? }],
        emits?: [{ name, payloadSchema? }],
        context?: [string]
      },
      page?: {
        route: string,
        params?: [{ name, type }],
        dataSources?: [{ name, description }],
        layout?: { title?, meta? }
      },
      module?: {
        functions: [{ name, signature, returns?, errors?, sideEffects? }]
      },
      api?: {
        endpoints: [{ method, path, auth?, requestSchema?, responseSchema?, errors? }]
      },
      graphql?: {
        sdl?: string,
        operations?: { queries?: [string], mutations?: [string], subscriptions?: [string] }
      },
      cli?: {
        commands: [{ name, args?: [string], flags?: [string], exitCodes?: [int] }],
        io?: { stdin?: string, stdout?: string }
      },
      job?: {
        trigger: { schedule?: string, event?: string },
        inputs?: [string], outputs?: [string], retryPolicy?: string
      },
      message?: {
        topics: [{ name, direction: "publish"|"subscribe", schema?, qos? }]
      },
      config?: {
        keys: [{ name, type, default?, required?, source?: "env"|"file"|"secret" }]
      },
      version?: string,
      stability?: "experimental" | "stable"
    }

Guidance for ${STACK}:
 - nextjs: prefer interface.type="page" or "component"; include interface.page.route and any props in interface.component.props.
 - python (non‑API): interface.type="module"; include function signatures in interface.module.functions.
 - python with ${API_STYLE}=rest|graphql: interface.type="api" or "graphql" with endpoints or SDL/operations.

ORGANIZATION & QUALITY
 - Group by feature or layer; ensure modularity and reuse.
 - Explain placement in directory structure and how files interact.
 - Document cross‑file dependencies and interfaces; avoid circular references.
 - Tailor sections based on ${STACK}. For Next.js, reflect the app routing model and
   UI composition. For Python backends, reflect API style (${API_STYLE}), data contracts,
   and service boundaries.

IMPORTANT: Output valid JSON only (no comments, no trailing commas).
