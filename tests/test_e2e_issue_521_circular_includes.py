"""
E2E Test for Issue #521: Circular <include> tags silently produce corrupted output.

This test exercises the full CLI path: `pdd preprocess --recursive` with real circular
prompt files on disk. No mocking of the preprocessor. This verifies the user-facing
behavior: running `pdd preprocess` on circular includes must produce an error, not
silently corrupted output written to the output file.
"""

import os
import pytest
from pathlib import Path
from click.testing import CliRunner

from pdd.cli import cli


@pytest.fixture(autouse=True)
def set_pdd_path(monkeypatch):
    import pdd
    pdd_package_dir = Path(pdd.__file__).parent
    monkeypatch.setenv("PDD_PATH", str(pdd_package_dir))


def _find_output_file(tmp_path: Path) -> str:
    """Find the preprocessed output file in tmp_path (generated by construct_paths)."""
    # construct_paths typically writes to a file with _preprocessed or similar suffix
    # Search for any new .prompt or .txt files that aren't our input files
    for f in tmp_path.rglob("*"):
        if f.is_file() and "preprocessed" in f.name.lower():
            return f.read_text()
    # Fallback: check for any file written by the command
    for f in sorted(tmp_path.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True):
        if f.is_file() and f.suffix in (".prompt", ".txt", ""):
            content = f.read_text()
            if len(content) > 100:  # Corrupted output is ~1184+ bytes
                return content
    return ""


class TestIssue521CircularIncludesE2E:
    """E2E: `pdd preprocess --recursive` on circular includes must error, not silently corrupt."""

    def test_circular_includes_cli_must_not_silently_corrupt(self, tmp_path, monkeypatch):
        """Reproduce the exact bug from the issue: A includes B, B includes A."""
        monkeypatch.chdir(tmp_path)

        a_file = tmp_path / "a_python.prompt"
        b_file = tmp_path / "b_python.prompt"
        output_file = tmp_path / "output.txt"

        a_file.write_text("Hello\n<include>b_python.prompt</include>\n")
        b_file.write_text("World\n<include>a_python.prompt</include>\n")

        runner = CliRunner(mix_stderr=False)
        result = runner.invoke(cli, [
            "--force", "preprocess",
            str(a_file), "--recursive",
            "--output", str(output_file),
        ])

        # The bug: exit code 0 with "Hello" repeated ~82 times in the output file.
        # Correct behavior: non-zero exit code OR output without massive duplication.
        if result.exit_code != 0:
            return  # Error detected — acceptable

        if output_file.exists():
            content = output_file.read_text()
        else:
            content = result.output

        hello_count = content.count("Hello")
        world_count = content.count("World")

        assert hello_count <= 2 and world_count <= 2, (
            f"Circular include silently produced corrupted output (exit code 0): "
            f"'Hello' appeared {hello_count} times, 'World' appeared {world_count} times. "
            f"Expected an error or at most 2 occurrences."
        )

    def test_self_referencing_include_cli(self, tmp_path, monkeypatch):
        """A file that includes itself must not silently corrupt."""
        monkeypatch.chdir(tmp_path)

        self_file = tmp_path / "self_python.prompt"
        output_file = tmp_path / "output.txt"

        self_file.write_text("Content\n<include>self_python.prompt</include>\n")

        runner = CliRunner(mix_stderr=False)
        result = runner.invoke(cli, [
            "--force", "preprocess",
            str(self_file), "--recursive",
            "--output", str(output_file),
        ])

        if result.exit_code != 0:
            return

        content = output_file.read_text() if output_file.exists() else result.output
        content_count = content.count("Content")
        assert content_count <= 2, (
            f"Self-referencing include silently corrupted (exit code 0): "
            f"'Content' appeared {content_count} times."
        )

    def test_three_file_cycle_cli(self, tmp_path, monkeypatch):
        """A→B→C→A cycle via CLI must not silently corrupt."""
        monkeypatch.chdir(tmp_path)

        (tmp_path / "a_python.prompt").write_text("AAA\n<include>b_python.prompt</include>\n")
        (tmp_path / "b_python.prompt").write_text("BBB\n<include>c_python.prompt</include>\n")
        (tmp_path / "c_python.prompt").write_text("CCC\n<include>a_python.prompt</include>\n")
        output_file = tmp_path / "output.txt"

        runner = CliRunner(mix_stderr=False)
        result = runner.invoke(cli, [
            "--force", "preprocess",
            str(tmp_path / "a_python.prompt"), "--recursive",
            "--output", str(output_file),
        ])

        if result.exit_code != 0:
            return

        content = output_file.read_text() if output_file.exists() else result.output
        aaa_count = content.count("AAA")
        assert aaa_count <= 2, (
            f"Three-file cycle silently corrupted (exit code 0): "
            f"'AAA' appeared {aaa_count} times."
        )
