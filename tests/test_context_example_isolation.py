"""Tests for verifying context example files follow proper test isolation patterns.

Issue #349: Tests generated by pdd sync may pass in isolation but fail during
collection when run with other modules due to sys.modules pollution at module level.

This test file verifies that context example files do NOT introduce module-level
sys.modules pollution that would affect other test files during pytest collection.
"""

import ast
import os
import re
from pathlib import Path
from typing import List, Tuple

import pytest


def get_project_root() -> Path:
    """Get the project root directory."""
    current = Path(__file__).parent
    while current != current.parent:
        if (current / "context").is_dir():
            return current
        current = current.parent
    raise RuntimeError("Could not find project root with context/ directory")


def get_all_context_example_files() -> List[Path]:
    """Get all context example files that may pollute sys.modules."""
    project_root = get_project_root()
    context_dir = project_root / "context"

    # Find all *_example.py files in context/ (including subdirectories)
    example_files = list(context_dir.glob("**/*_example.py"))
    return example_files


def parse_file_for_sys_modules_assignments(file_path: Path) -> List[Tuple[int, str]]:
    """Parse a Python file and find sys.modules assignments without restoration.

    Returns a list of (line_number, code_snippet) tuples for problematic assignments.
    """
    try:
        source = file_path.read_text()
    except Exception:
        return []  # Skip files that can't be read

    problematic_assignments = []

    # Look for patterns like:
    # sys.modules["xxx"] = MagicMock()
    # sys.modules["xxx"] = mock_obj
    #
    # These are problematic at module level if there's no corresponding:
    # - del sys.modules["xxx"]
    # - sys.modules["xxx"] = original_value
    # - sys.modules.pop("xxx", None)

    # Pattern to find sys.modules assignments
    assignment_pattern = re.compile(
        r'^\s*sys\.modules\s*\[\s*["\']([^"\']+)["\']\s*\]\s*=\s*(.+)$',
        re.MULTILINE
    )

    # Pattern to find restoration/cleanup
    restore_pattern = re.compile(
        r'(del\s+sys\.modules|sys\.modules\.pop|sys\.modules\s*\[\s*["\'][^"\']+["\']\s*\]\s*=\s*(_saved|_original|original|saved))',
        re.IGNORECASE
    )

    # Pattern to find if it's inside a function/fixture (not module level)
    # We use AST for more accurate detection
    try:
        tree = ast.parse(source)
    except SyntaxError:
        return []  # Skip files with syntax errors

    # Collect all function/class scopes
    function_ranges = []
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if hasattr(node, 'lineno') and hasattr(node, 'end_lineno'):
                function_ranges.append((node.lineno, node.end_lineno or node.lineno))

    # Check each line for sys.modules assignments
    lines = source.split('\n')
    for i, line in enumerate(lines, 1):
        match = assignment_pattern.match(line)
        if match:
            module_name = match.group(1)
            assigned_value = match.group(2).strip()

            # Check if this line is inside a function/class (not module level)
            is_module_level = True
            for start, end in function_ranges:
                if start <= i <= end:
                    is_module_level = False
                    break

            if is_module_level:
                # Check if there's corresponding cleanup nearby (within 50 lines)
                # or if it's part of a save/restore pattern
                has_restoration = False

                # Look for restoration patterns in the file
                if restore_pattern.search(source):
                    # Check if there's a pattern like:
                    # _saved = sys.modules.get("xxx") or _original = {}
                    # before the assignment
                    save_pattern = re.compile(
                        rf'(_saved|_original|original|saved)\s*[=\[].*{re.escape(module_name)}',
                        re.IGNORECASE
                    )
                    if save_pattern.search(source):
                        has_restoration = True

                if not has_restoration:
                    problematic_assignments.append((i, line.strip()))

    return problematic_assignments


class TestContextExampleIsolation:
    """Tests verifying context example files don't pollute sys.modules."""

    def test_no_module_level_sys_modules_pollution(self):
        """Verify no context example files have unrestored sys.modules assignments.

        This test detects the root cause of Issue #349: context example files
        that assign MagicMock() to sys.modules at module level without restoration.

        Such assignments pollute sys.modules during pytest collection, causing
        tests to pass in isolation but fail when run with other modules.

        The correct pattern is documented in context/pytest_isolation_example.py
        (Pattern 7): save original, mock, import, restore immediately.
        """
        example_files = get_all_context_example_files()
        assert len(example_files) > 0, "Should find context example files"

        violations = []

        for file_path in example_files:
            problematic = parse_file_for_sys_modules_assignments(file_path)
            if problematic:
                relative_path = file_path.relative_to(get_project_root())
                for line_num, code in problematic:
                    violations.append(
                        f"  {relative_path}:{line_num}: {code}"
                    )

        if violations:
            violation_list = "\n".join(violations)
            pytest.fail(
                f"Found {len(violations)} module-level sys.modules assignment(s) "
                f"without restoration (causes test pollution during collection):\n\n"
                f"{violation_list}\n\n"
                f"These assignments pollute sys.modules for all subsequent tests.\n"
                f"Fix: Follow Pattern 7 in context/pytest_isolation_example.py - "
                f"save original value, mock, import code under test, restore immediately."
            )

    def test_example_files_found(self):
        """Verify we can find context example files for testing."""
        example_files = get_all_context_example_files()
        assert len(example_files) > 10, (
            f"Expected to find many example files, found {len(example_files)}"
        )

    def test_known_problematic_files_are_detected(self):
        """Verify known problematic files from Issue #349 are detected.

        These are the specific files identified in the root cause analysis:
        - context/commands/sessions_example.py
        - context/server/routes/auth_example.py
        - context/server/routes/commands_example.py
        - context/server/routes/prompts_example.py
        """
        project_root = get_project_root()
        known_problematic = [
            "context/commands/sessions_example.py",
            "context/server/routes/auth_example.py",
            "context/server/routes/commands_example.py",
            "context/server/routes/prompts_example.py",
        ]

        detected_files = []

        for relative_path in known_problematic:
            file_path = project_root / relative_path
            if file_path.exists():
                problematic = parse_file_for_sys_modules_assignments(file_path)
                if problematic:
                    detected_files.append(relative_path)

        # This test fails if ANY of the known problematic files are detected
        # (meaning they haven't been fixed yet)
        if detected_files:
            pytest.fail(
                f"Known problematic files still have unrestored sys.modules assignments:\n"
                f"  {', '.join(detected_files)}\n\n"
                f"These files need to be fixed to restore sys.modules after mocking."
            )


class TestSysModulesNotPollutedDuringCollection:
    """Tests that verify pytest collection doesn't see polluted sys.modules.

    These tests run after collection and verify that importing context example
    files doesn't leave behind MagicMock objects in sys.modules.
    """

    def test_pdd_modules_are_not_mocked_after_collection(self):
        """Verify pdd.* modules in sys.modules are not MagicMock objects.

        If context example files pollute sys.modules during collection,
        we'll see MagicMock objects here instead of real modules.
        """
        import sys
        from unittest.mock import MagicMock

        polluted_modules = []

        for name, module in sys.modules.items():
            if name.startswith("pdd"):
                # Check if it's a MagicMock (pollution) vs real module
                if isinstance(module, MagicMock):
                    polluted_modules.append(name)

        if polluted_modules:
            pytest.fail(
                f"sys.modules contains MagicMock objects for pdd modules "
                f"(indicates test pollution during collection):\n"
                f"  {', '.join(sorted(polluted_modules))}\n\n"
                f"This is caused by context example files that mock sys.modules "
                f"at module level without restoration."
            )
