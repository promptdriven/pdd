"""
Tests for Issue #429: Basename sanitization inconsistency causes CLI mode failures

This test suite verifies that operation_log.py correctly sanitizes basenames
containing slashes (/) when generating file paths for logs, fingerprints, and
run reports. The bug causes CLI mode to crash with FileNotFoundError when using
subdirectory basenames like 'core/cloud' because operation_log.py doesn't
sanitize paths, while sync_determine_operation.py and sync_orchestration.py do.

Issue: https://github.com/promptdriven/pdd/issues/429
"""

import json
import pytest
from pathlib import Path
from unittest.mock import patch

from pdd import operation_log


@pytest.fixture
def temp_pdd_env(tmp_path):
    """
    Sets up a temporary PDD_DIR and META_DIR for file operations.
    Patches the module-level constants to use this temp path.
    """
    pdd_dir = tmp_path / ".pdd"
    meta_dir = pdd_dir / "meta"

    with patch("pdd.operation_log.PDD_DIR", str(pdd_dir)), \
         patch("pdd.operation_log.META_DIR", str(meta_dir)):
        yield meta_dir


def test_get_paths_with_subdirectory_basename(temp_pdd_env):
    """
    Test 1: Verify that path generation functions sanitize subdirectory basenames.

    This test directly checks that get_log_path(), get_fingerprint_path(), and
    get_run_report_path() convert slashes to underscores in basenames.

    Before fix: Returns paths like '.pdd/meta/core/cloud_python.json' (tries to
                create subdirectory)
    After fix:  Returns paths like '.pdd/meta/core_cloud_python.json' (flat file)
    """
    basename = "core/cloud"
    lang = "python"

    log_path = operation_log.get_log_path(basename, lang)
    fp_path = operation_log.get_fingerprint_path(basename, lang)
    rr_path = operation_log.get_run_report_path(basename, lang)

    # All paths should use sanitized basename (slash -> underscore)
    assert log_path == Path(temp_pdd_env) / "core_cloud_python_sync.log"
    assert fp_path == Path(temp_pdd_env) / "core_cloud_python.json"
    assert rr_path == Path(temp_pdd_env) / "core_cloud_python_run.json"

    # Verify paths don't contain directory separators in filename
    assert "/" not in log_path.name
    assert "/" not in fp_path.name
    assert "/" not in rr_path.name


def test_append_log_entry_with_subdirectory_basename(temp_pdd_env):
    """
    Test 2: Verify that log entries can be written with subdirectory basenames.

    This test performs a complete write/read cycle to ensure no FileNotFoundError
    occurs when writing log entries with subdirectory basenames.

    Before fix: Raises FileNotFoundError trying to write to non-existent subdirectory
    After fix:  Successfully writes to sanitized path and can read back the entry
    """
    basename = "api/auth"
    lang = "typescript"
    entry = {"operation": "test", "success": True, "timestamp": "2026-01-29T00:00:00"}

    operation_log.ensure_meta_dir()

    # Should NOT raise FileNotFoundError
    operation_log.append_log_entry(basename, lang, entry)

    # Verify file exists at sanitized path
    log_path = operation_log.get_log_path(basename, lang)
    assert log_path.exists()
    assert log_path == Path(temp_pdd_env) / "api_auth_typescript_sync.log"

    # Verify we can read it back
    entries = operation_log.load_operation_log(basename, lang)
    assert len(entries) == 1
    assert entries[0]["operation"] == "test"
    assert entries[0]["success"] is True


def test_save_fingerprint_with_subdirectory_basename(tmp_path):
    """
    Test 3: Verify fingerprint operations work with subdirectory basenames.

    This is a cross-module integration test that verifies paths generated by
    operation_log.py match what sync_determine_operation.py expects when reading.
    This is the core reader/writer mismatch bug.

    Before fix: Writer uses '.pdd/meta/backend/utils/credit_helpers_python.json'
                Reader uses '.pdd/meta/backend_utils_credit_helpers_python.json'
                Result: Reader can't find the file, state desynchronization
    After fix:  Both use '.pdd/meta/backend_utils_credit_helpers_python.json'
    """
    from pdd.sync_determine_operation import read_fingerprint, get_meta_dir

    basename = "backend/utils/credit_helpers"
    language = "python"

    meta_dir = tmp_path / ".pdd" / "meta"
    meta_dir.mkdir(parents=True)

    with patch("pdd.operation_log.META_DIR", str(meta_dir)), \
         patch("pdd.sync_determine_operation.get_meta_dir", return_value=meta_dir):

        # Save fingerprint using operation_log (the writer)
        operation_log.save_fingerprint(
            basename=basename,
            language=language,
            operation="generate",
            paths={"prompt": "prompts/backend/utils/credit_helpers_python.prompt"},
            cost=0.1,
            model="test-model"
        )

        # Verify file created with sanitized name (underscores, not slashes)
        expected_path = meta_dir / "backend_utils_credit_helpers_python.json"
        assert expected_path.exists(), \
            f"Fingerprint file not created at expected path: {expected_path}"

        # Verify the fingerprint file doesn't exist at the unsanitized path
        wrong_path = meta_dir / "backend" / "utils" / "credit_helpers_python.json"
        assert not wrong_path.exists(), \
            f"Fingerprint file should not exist at unsanitized path: {wrong_path}"

        # Verify sync_determine_operation can read it (path consistency check)
        # This is the critical test: reader must find what writer created
        result = read_fingerprint(basename, language)
        assert result is not None, \
            "sync_determine_operation.read_fingerprint() could not find the fingerprint " \
            "file created by operation_log.save_fingerprint() - path mismatch!"
        assert result.command == "generate"


def test_basename_sanitization_edge_cases(temp_pdd_env):
    """
    Test 4: Verify edge cases for basename sanitization.

    Tests various edge cases to ensure robust sanitization:
    - Multiple levels of nesting (a/b/c/d)
    - Deep nested paths

    All slashes should be converted to underscores, with no invalid characters
    or directory separators in the resulting filenames.
    """
    test_cases = [
        # (basename, expected_log_filename)
        ("a/b/c/d", "a_b_c_d_python_sync.log"),
        ("deep/nested/module/path", "deep_nested_module_path_python_sync.log"),
        ("frontend/components/marketplace", "frontend_components_marketplace_python_sync.log"),
    ]

    for basename, expected_filename in test_cases:
        log_path = operation_log.get_log_path(basename, "python")
        assert log_path.name == expected_filename, \
            f"For basename '{basename}', expected filename '{expected_filename}' " \
            f"but got '{log_path.name}'"

        # Verify no slashes in the filename part
        assert "/" not in log_path.name, \
            f"Filename '{log_path.name}' contains slash - should be sanitized"

        # Verify the file can be written to (no FileNotFoundError)
        operation_log.ensure_meta_dir()
        log_path.write_text('{"test": "data"}\n')
        assert log_path.exists()
