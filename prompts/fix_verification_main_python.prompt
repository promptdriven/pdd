% You are an expert Python engineer. Your goal is to write a Python function, "fix_verification_main", that will be the CLI wrapper for the "verify" command as described in the README.md. This function will verify the functional correctness of generated code by executing a specified program and using an LLM to judge the program's output against the original prompt's intent. It will handle the verification process using either the fix_verification_errors function or fix_verification_errors_loop function depending on whether the --loop option is used.

<include>./context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
            Context parameters used:
            - strength (float): Model strength parameter, defaults to the global DEFAULT_STRENGTH
            - temperature (float): Model temperature parameter, defaults to 0
            - time (float): Time parameter for LLM calls, defaults to the global DEFAULT_TIME
            - force (bool): Whether to force overwrite existing files
            - quiet (bool): Whether to suppress output messages
            - verbose (bool): Whether to enable verbose output for debugging purposes
        - `prompt_file` (str): The filename of the prompt file that generated the code being verified.
        - `code_file` (str): The filename of the code file to be verified and potentially fixed.
        - `program_file` (str): The filename of the executable program to run for verification.
        - `output_results` (Optional[str]): Path where to save the verification and fixing results log.
        - `output_code` (Optional[str]): Path where to save the final code file after verification attempts.
        - `output_program` (Optional[str]): Path where to save the final program file after verification attempts.
        - `loop` (bool): If True, perform iterative verification with error fixing.
        - `verification_program` (Optional[str]): Path to a Python program that verifies if the code still runs correctly after modifications. Required if --loop is used.
        - `max_attempts` (int): Maximum number of verification attempts before giving up. Default is 3.
        - `budget` (float): Maximum cost allowed for the verification process. Default is $5.0.
    Outputs:
        - Returns a tuple containing:
            - `bool`: Success status of verification (True if program verified successfully)
            - `str`: The final program code after verification attempts
            - `str`: The final code file content after verification attempts
            - `int`: Total number of attempts made
            - `float`: Total cost of verification process
            - `str`: Name of the model used

% Important Implementation Notes:
1. File Path Handling and Parameter Passing:
   - When calling `fix_verification_errors_loop`, pass the *content* of the `prompt_file`, the *path* to the `code_file`, the *path* to the `program_file`, the *path* to the `verification_program`, and the `llm_time` argument using the `time` value from `ctx.obj`. Also pass the path for the `verification_log_file` if provided. Do not pass output file paths to the loop.
   - When calling `fix_verification_errors`, read the contents of the files first and pass them as strings (including the combined program output), and pass the `time` value from `ctx.obj`.
   - Use `construct_paths` to generate default output paths when not explicitly provided. When calling `construct_paths`, pass `context_override=ctx.obj.get('context')` so a global `--context` is honored. If `construct_paths` raises an "invalid command" error for `verify`, fall back to manual handling: read input files and derive default paths, including `output_program`. For other `construct_paths` errors, print a formatted error and `sys.exit(1)`.
   - Ensure the final program content is written to the `output_program` path when one is resolved.

2. Error Handling Requirements:
   - Validate verification program:
     * Raise `click.UsageError` if `--loop` is used without `--verification-program`
   - Handle file operations:
     * Use try/except blocks for file reading/writing
     * Provide formatted error messages using rich.print
   - Exit with sys.exit(1) on critical errors

3. Verification Process:
   - For `loop=True`:
     * Call `fix_verification_errors_loop` with all required parameters including `max_attempts`, `budget`, `llm_time` (from `ctx.obj['time']`), and the `verification_log_file` path. Pass through `verbose` and default `program_args=[]`.
     * This handles the entire iterative verification and fixing process.
   - For `loop=False`:
     * Execute the `program_file` and capture stdout/stderr. Choose interpreter by extension: `.py` via an environment-aware Python (`detect_host_python_executable()`), `.js` via `node`, `.sh` via `bash`. Set `cwd` to the program directory, set `PYTHONUNBUFFERED=1`, and use a 60s timeout. If stderr contains a Python syntax error, prefix it with `SYNTAX_ERROR:`.
     * Combine stdout and stderr for verification (prepend a `--- STDERR ---` delimiter only when stderr is present).
     * Call `fix_verification_errors` once, passing the *content* of the prompt file, the *content* of the code file, the *content* of the program file, the combined program output, and `time`.
     * If issues are found, it will generate a single round of fixes.

4. Verbose Output:
   - Add a `verbose` parameter to both function calls.
   - When `verbose` is True, provide additional debugging information during the verification process, including resolved paths, invoked command, environment hints, and formatted panels for errors.

5. User Feedback:
   - Use rich.print for formatted output
   - Show success/failure status
   - Display total attempts and cost
   - Show model name used
   - List saved file paths (including `output_code`, `output_results`, and `output_program`)
   - Summarize verification results and any improvements made
   - In single-pass mode, write a "PDD Verify Results (Single Pass)" log with timestamp, files, success, issue count, change flags, model, cost, explanation, and combined program output.
   - In loop mode, delegate log writing to `fix_verification_errors_loop`; the wrapper only confirms the expected log path.
   - Note: Output files are written when specified, regardless of verification success, to allow inspection of the final state

6. Success Semantics:
   - Single-pass success is True if either no issues are found, or fixes are proposed (without re-running). For iterative validation and re-runs, use `--loop`.
   - Loop-mode success is whatever `fix_verification_errors_loop` returns.

7. Return Values:
   - Return a tuple with (success_status, final_program, final_code, attempts, total_cost, model_name)

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `fix_verification_errors` function:
      <fix_verification_errors_example>
      <include>context/fix_verification_errors_example.py</include>
      </fix_verification_errors_example>

      - Here is an example of how to use the `fix_verification_errors_loop` function:
      <fix_verification_errors_loop_example>
      <include>context/fix_verification_errors_loop_example.py</include>
      </fix_verification_errors_loop_example>

      - Here is how to get the language:
      <get_language_example>
      <include>context/get_language_example.py</include>
      </get_language_example>
   </internal_example_modules>
</examples>

% Here is the pdd README for the 'verify' command that describes how it should work:
<cli_command_readme>
   <include>./README.md</include>
</cli_command_readme>
