# sync_orchestration_python.prompt

Create a Python module that orchestrates the complete PDD (Prompt-Driven Development) sync workflow by coordinating operations and animations in parallel.

## Context

<readme>
    <include>README.md</include>
</readme>

<whitepaper>
    <include>./docs/whitepaper.md</include>
</whitepaper>

The sync command is the primary command in PDD that automatically executes the complete workflow loop from dependency injection through code generation, testing, and verification. This orchestration module coordinates the execution while providing real-time feedback to users.

## Requirements

Create a module with the following main function:

```python
def sync_orchestration(
    basename: str,
    language: str = "python",
    max_attempts: int = 3,
    budget: float = 10.0,
    skip_verify: bool = False,
    skip_tests: bool = False,
    target_coverage: float = 90.0,
    log: bool = False,
    force: bool = False,
    strength: float = 0.5,
    temperature: float = 0.0,
    time_param: float = 0.25,
    verbose: bool = False,
    quiet: bool = False,
    output_cost: Optional[str] = None,
    review_examples: bool = False,
    local: bool = False,
    context_config: Optional[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Orchestrate the complete PDD sync workflow with parallel animation.
    
    If log=True, display sync log for this basename instead of running sync.
    The verbose flag (global option) controls detail level of log output.

    Path configuration is handled via `context_config`, which overrides default
    locations for prompts, code, examples, and tests directories.
    
    Returns a dictionary with:
    - 'success': bool indicating overall success
    - 'operations_completed': List of completed operations
    - 'total_cost': float total cost of all operations
    - 'total_time': float total time elapsed
    - 'final_state': Dict with final file states
    - 'errors': List of any errors encountered
    - 'log_entries': List of log entries (when log=True)
    """
```

Here are examples of how to use the internal functions:
<examples>
    - Here is how to use the `sync_animation` function:
      <sync_animation_example>
        <include>context/sync_animation_example.py</include>
      </sync_animation_example>
      
    - Here is how to use the `sync_determine_operation` function:
      <sync_determine_operation_example>
        <include>context/sync_determine_operation_example.py</include>
      </sync_determine_operation_example>

    - For examples of how to execute core PDD operations, refer to their respective test files included below. These provide the most up-to-date usage patterns.
      <auto_deps_main_example>
        <include>context/auto_deps_main_example.py</include>
      </auto_deps_main_example>
      <code_generator_main_example>
        <include>context/code_generator_main_example.py</include>
      </code_generator_main_example>
      <context_generator_main_example>
        <include>context/context_generator_main_example.py</include>
      </context_generator_main_example>
      <crash_main_example>
        <include>context/crash_main_example.py</include>
      </crash_main_example>
      <fix_verification_main_example>
        <include>context/fix_verification_main_example.py</include>
      </fix_verification_main_example>
      <cmd_test_main_example>
        <include>context/cmd_test_main_example.py</include>
      </cmd_test_main_example>
      <fix_main_example>
        <include>context/fix_main_example.py</include>
      </fix_main_example>
      <update_main_example>
        <include>context/update_main_example.py</include>
      </update_main_example>
</examples>

## Workflow Orchestration

The module should implement the PDD workflow as described in the whitepaper:

1. **Log Mode Check**: If `--log` flag is set, display sync log and return
2. **Single Instance Enforcement**: Use `sync_determine_operation` to acquire lock and prevent concurrent runs
3. **Initial Analysis**: Analyze current file state to determine starting point
4. **Operation Loop**: Execute operations in sequence until synchronized
5. **Parallel Animation**: Run `sync_animation` in a separate thread throughout
6. **Lock Management**: Ensure lock is released on completion or failure
7. **Error Handling**: Handle failures and retry logic within budget constraints
8. **Final Reporting**: Summarize results and costs

### Core Workflow Steps

The orchestrator should execute these operations in order as determined by `sync_determine_operation`:

1. **auto-deps**: Find and inject relevant dependencies into the prompt
2. **generate**: Create or update the code module from the prompt  
3. **example**: Generate usage example if it doesn't exist or is outdated
4. **crash**: Fix any runtime errors to make code executable
5. **verify**: Run functional verification against prompt intent (unless --skip-verify)
6. **test**: Generate comprehensive unit tests (unless --skip-tests)
7. **fix**: Resolve any bugs found by unit tests
8. **update**: Back-propagate any learnings to the prompt file

### Handling Skipped Operations
If `--skip-verify` or `--skip-tests` flags are used, the orchestrator should not simply ignore the step. To ensure the state machine progresses correctly, it should:
1. Log that the operation was skipped.
2. Simulate a successful run for that operation by creating a `RunReport` and saving it. This updates the state, allowing `determine_sync_operation` to correctly select the next step.

### Parallel Animation System

The module should:

1. **Start Animation Thread**: Launch `sync_animation` before beginning operations
2. **Update Animation State**: Use mutable list references to update animation in real-time:
   - `function_name_ref`: Current operation being executed
   - `cost_ref`: Running total of costs
   - `prompt_color/code_color/example_color/tests_color`: Visual status indicators
   - `prompt_path_ref/code_path_ref/example_path_ref/tests_path_ref`: File paths
3. **Stop Animation**: Set stop_event when workflow completes

### Operation Execution

For each operation:

1. **Determine Next Step**: Call `sync_determine_operation`.
2. **Update Animation**: Set `function_name_ref` to the current operation.
3. **Execute Command**: Run the appropriate PDD `*_main` function.
4. **Track Results**: Update cost, file paths, and status colors.
5. **Persist State**: **If the operation was successful, save a new `Fingerprint` to disk.** This updates the state so the next call to `determine_sync_operation` can make a new decision.
6. **Handle Errors**: Implement retry logic up to `max_attempts` or break the loop on a definitive failure.

### State and Path Management

The orchestrator should:

- **Construct File Paths**: Use the `get_pdd_file_paths(basename, language, context_config)` helper function to resolve all required file paths. This allows for centralized configuration.
- **Track File States**: Monitor which files exist and their modification times
- **Update Animation Colors**: Set colors based on file status:
  - Green: File exists and up-to-date
  - Yellow: File being processed
  - Red: File has errors or missing
  - Blue: File analysis in progress
- **Manage Lock Lifecycle**: Ensure sync lock is properly acquired at start and released at end
- **Handle Lock Failures**: Exit gracefully if another sync is already running

### Error Handling and Recovery

Implement robust error handling:

- **Lock Acquisition Failure**: Exit immediately with clear message if another sync is running
- **Budget Constraints**: Stop if total cost exceeds budget
- **Retry Logic**: If an operation fails, the orchestrator MUST retry the operation up to `max_attempts` times before considering it a definitive failure. It should not exit the loop on the first failure of an operation.
- **Graceful Degradation**: Continue workflow even if non-critical steps fail
- **User Feedback**: Provide clear error messages through animation
- **Lock Cleanup**: Always release lock, even on exceptions or early exits

### Integration with Main Components

The orchestrator should import and use:

```python
from .sync_determine_operation import sync_determine_operation
from .sync_animation import sync_animation
from .auto_deps_main import auto_deps_main
from .code_generator_main import code_generator_main
from .context_generator_main import context_generator_main
from .crash_main import crash_main
from .fix_verification_main import fix_verification_main
from .cmd_test_main import cmd_test_main
from .fix_main import fix_main
from .update_main import update_main
```

### Command Execution Pattern

For each PDD operation, construct appropriate arguments based on the up-to-date usage patterns found in the corresponding test files, which are included in the `<examples>` section of this prompt. The orchestrator is responsible for adapting these examples into robust calls that handle cost tracking, state persistence, and retry logic.

### Output Format

Return comprehensive results:

```python
{
    'success': True,
    'operations_completed': ['auto-deps', 'generate', 'example', 'verify', 'test'],
    'total_cost': 2.45,
    'total_time': 120.5,
    'final_state': {
        'prompt': {'exists': True, 'path': '...', 'status': 'current'},
        'code': {'exists': True, 'path': '...', 'status': 'generated'},
        'example': {'exists': True, 'path': '...', 'status': 'current'},
        'test': {'exists': True, 'path': '...', 'status': 'passing'}
    },
    'errors': [],
    'skipped_operations': ['verify'] if skip_verify else [],
    'git_commits_created': 3,
    'test_coverage_achieved': 92.5
}
```

## Implementation Requirements

1. **Lock Management**: Use context managers or try/finally for reliable lock cleanup
2. **Threading**: Use threading.Thread for animation, threading.Event for coordination
3. **Context Management**: Create Click context objects for command execution
4. **Path Resolution**: Handle relative and absolute paths correctly
5. **File Operations**: Use pathlib.Path for cross-platform compatibility
6. **Cost Tracking**: Accumulate costs from all operations
7. **Time Tracking**: Monitor elapsed time for each operation
8. **Exception Handling**: Catch and handle all operation failures gracefully, always releasing locks

## Dependencies

- Standard library modules (threading, time, pathlib, subprocess, json)
- Click for context management
- All PDD command modules for operation execution
- sync_determine_operation for workflow intelligence
- sync_animation for user feedback

## Usage Examples

```python
# Basic sync execution
result = sync_orchestration(
    basename="calculator",
    language="python"
)

# View sync log
result = sync_orchestration(
    basename="calculator",
    language="python",
    log=True
)

# View detailed sync log (with verbose flag)
result = sync_orchestration(
    basename="calculator", 
    language="python",
    log=True,
    verbose=True
)

# Result handling
if not result['success']:
    if 'lock_conflict' in result.get('errors', []):
        print("Another sync is already running for this module")
        exit(1)

# Advanced sync with custom settings  
result = sync_orchestration(
    basename="data_processor",
    language="python",
    budget=15.0,
    target_coverage=95.0,
    skip_verify=False,
    context_config={'code_dir': 'backend/src', 'tests_dir': 'backend/tests'}
)
```

## Main Workflow and Lock Integration

The orchestrator must use the `SyncLock` context manager to ensure only one sync process runs at a time for a given unit. The entire workflow should be wrapped in this lock.

```python
def sync_orchestration(..., log=False, verbose=False):
    # Handle log mode first
    if log:
        # Code to display the log...
        return

    try:
        # The main workflow is wrapped in the SyncLock context manager.
        # This will raise TimeoutError if the lock is already held.
        with SyncLock(basename, language) as lock:
            
            # 1. Start animation thread here
            # ...

            # 2. Begin the main workflow loop
            while True:
                # 3. Determine the next operation
                decision = determine_sync_operation(...)
                
                # 4. Execute the operation
                # ...
                
                # 5. Save new state (fingerprint) on success
                # ...

                # 6. Break loop if finished, in conflict, or on error
                if decision.operation in ['nothing', 'fail_and_request_manual_merge']:
                    break
    
    except TimeoutError:
        # Handle the case where the lock could not be acquired
        return {'success': False, 'errors': ['Another sync process is running.']}
    
    except Exception as e:
        # Handle other unexpected errors
        # ...

    finally:
        # 7. Stop animation thread
        # ...

    # 8. Return final results
    # ...
```

The module should be the central coordinator that brings together all PDD components into a seamless, animated workflow that embodies the prompt-driven development philosophy described in the whitepaper.