# sync_orchestration_python.prompt

Create a Python module that orchestrates the complete PDD (Prompt-Driven Development) sync workflow by coordinating operations and animations in parallel.

## Context

<readme>
    <include>README.md</include>
</readme>

<whitepaper>
    <include>./docs/whitepaper.md</include>
</whitepaper>

The sync command is the primary command in PDD that automatically executes the complete workflow loop from dependency injection through code generation, testing, and verification. This orchestration module coordinates the execution while providing real-time feedback to users via a Textual-based TUI.

## Architecture

This module works in conjunction with related modules:

- **sync_main**: Handles CLI parameter extraction, validation, language detection, path resolution via `construct_paths()`, and .pddrc configuration management
- **sync_orchestration**: Focuses solely on workflow orchestration, TUI coordination, and operation execution using the resolved paths provided by sync_main
- **sync_tui**: Provides the Textual-based TUI components (`SyncApp`, `show_exit_animation`) that display real-time animation and log output

## Requirements

### Function Signature

```python
def sync_orchestration(
    basename: str,
    target_coverage: float = 90.0,
    language: str = "python",
    prompts_dir: str = "prompts",
    code_dir: str = "src",
    examples_dir: str = "examples",
    tests_dir: str = "tests",
    max_attempts: int = 3,
    budget: float = 10.0,
    skip_verify: bool = False,
    skip_tests: bool = False,
    dry_run: bool = False,
    force: bool = False,
    strength: float = DEFAULT_STRENGTH,
    temperature: float = 0.0,
    time_param: float = 0.25,
    verbose: bool = False,
    quiet: bool = False,
    output_cost: Optional[str] = None,
    review_examples: bool = False,
    local: bool = False,
    context_config: Optional[Dict[str, str]] = None,
    context_override: Optional[str] = None,
    confirm_callback: Optional[Callable[[str, str], bool]] = None,
) -> Dict[str, Any]:
```

### Return Value

Returns a dictionary containing:
- `success`: bool indicating overall success
- `operations_completed`: List of completed operation names
- `skipped_operations`: List of skipped operation names
- `total_cost`: float total cost in dollars
- `total_time`: float elapsed time in seconds
- `final_state`: Dict mapping file types to `{exists, path}` info
- `errors`: List of error messages
- `error`: Semicolon-joined error string or None
- `model_name`: Name of the last model used
- `log_entries`: List of log entries (only when `dry_run=True`)

## Dependencies

<examples>
    <sync_determine_operation_example>
        <include>context/sync_determine_operation_example.py</include>
    </sync_determine_operation_example>
    <auto_deps_main_example>
        <include>context/auto_deps_main_example.py</include>
    </auto_deps_main_example>
    <code_generator_main_example>
        <include>context/code_generator_main_example.py</include>
    </code_generator_main_example>
    <context_generator_main_example>
        <include>context/context_generator_main_example.py</include>
    </context_generator_main_example>
    <crash_main_example>
        <include>context/crash_main_example.py</include>
    </crash_main_example>
    <fix_verification_main_example>
        <include>context/fix_verification_main_example.py</include>
    </fix_verification_main_example>
    <cmd_test_main_example>
        <include>context/cmd_test_main_example.py</include>
    </cmd_test_main_example>
    <fix_main_example>
        <include>context/fix_main_example.py</include>
    </fix_main_example>
    <update_main_example>
        <include>context/update_main_example.py</include>
    </update_main_example>
    <get_test_command_example>
        <include>context/get_test_command_example.py</include>
    </get_test_command_example>
</examples>

Import from sync_determine_operation: `sync_determine_operation`, `get_pdd_file_paths`, `RunReport`, `SyncDecision`, `PDD_DIR`, `META_DIR`, `SyncLock`, `read_run_report`, `calculate_sha256`, `calculate_current_hashes`, `_safe_basename`, `Fingerprint`.

Import operation commands: `auto_deps_main`, `code_generator_main`, `context_generator_main`, `crash_main`, `fix_verification_main`, `cmd_test_main`, `fix_main`, `update_main`.

Other imports: `detect_host_python_executable`, `get_run_command_for_file`, `extract_failing_files_from_output`, `DEFAULT_STRENGTH`, `get_test_command_for_file`, `get_extension`.

## Workflow Operations

The orchestrator executes these operations as determined by `sync_determine_operation`:

1. **auto-deps**: Inject relevant dependencies into the prompt
2. **generate**: Create or update code from prompt
3. **example**: Generate usage example
4. **crash**: Fix runtime errors to make code executable
5. **verify**: Verify against prompt intent (unless `--skip-verify`)
6. **test**: Generate unit tests (unless `--skip-tests`)
7. **test_extend**: Add more tests to improve coverage when below target
8. **fix**: Resolve test failures
9. **update**: Back-propagate learnings to prompt

Terminal states: `all_synced`, `nothing`, `fail_and_request_manual_merge`, `error`, `analyze_conflict`

## Core Behaviors

### Dry-Run Mode

When `dry_run=True`, display the sync log at `.pdd/meta/{basename}_{language}_sync.log` (JSONL format) and return immediately. Normal mode shows concise output; verbose mode shows full details including decision type, confidence, and budget info.

### TUI Integration

1. Instantiate `SyncApp` with `worker_func` containing the main workflow loop
2. Use mutable reference lists (`function_name_ref`, `cost_ref`, `*_color_ref`, `*_path_ref`) and `stop_event` (threading.Event) to coordinate with TUI
3. Store app reference in `app_ref` list for confirmation dialogs via `app.request_confirmation()`
4. Track `user_confirmed_overwrite` to avoid repeated confirmation prompts
5. Call `show_exit_animation()` after completion (unless quiet mode)
6. After `app.run()` completes, check `app.worker_exception` for worker thread crashes; print error and traceback to stderr
7. If `app.run()` returns None, return error dict indicating sync was interrupted

### Headless Mode

Detect headless mode when `quiet=True`, no TTY (`not sys.stdout.isatty()`), or CI environment (`os.environ.get('CI')`). In headless mode:
- Set `PDD_FORCE=1` to skip API key prompts
- Run `sync_worker_logic()` directly without TUI
- Skip exit animation

### State Persistence

After each successful operation:
- Save a `Fingerprint` to disk with current file hashes
- This advances the state machine for subsequent `sync_determine_operation` calls

### Atomic State Updates

Use `AtomicStateUpdate` context manager (Issue #159 fix) to ensure run_report and fingerprint are written atomically:
- Write to temp file, then `os.replace()` for atomic rename
- On exception, rollback (clean up temp files, don't commit)
- Prevents state desynchronization from partial writes

### Skip Handling

When `skip_verify` or `skip_tests` is set:
- Log that the operation was skipped
- Save fingerprint with 'skip:' prefix to advance state machine (prevents infinite loops)
- Cascading: `skip_tests` also skips `verify` and `crash`
- When crash is skipped, create synthetic run_report to prevent infinite loop

### Post-Operation Validation

- After **generate**: Delete stale run_report to force re-validation
- After **crash**: Re-run example to verify fix, update run report
- After **fix**: Re-run tests to update run report
- After **test** and **test_extend**: Execute tests to create/update run report

### Multi-Language Test Support

For non-Python languages, use `get_test_command_for_file()` to determine the appropriate test runner command. The `_parse_test_output()` helper parses output from pytest, Jest/Vitest/Mocha, go test, and cargo test. For non-Python languages, set `max_attempts=0` to skip iterative loop and go directly to agentic fallback.

### Multiple Test Files (Bug #156)

Support tracking multiple test files via `test_files` in `pdd_files`. Use `extract_failing_files_from_output()` to parse pytest output and find actual failing files. When running fix, pass the correct failing test file to `fix_main()`.

## Helper Functions

Implement helpers for state management and test execution:

- Sync log management: `load_sync_log`, `create_sync_log_entry`, `update_sync_log_entry`, `append_sync_log`, `log_sync_event`
- State persistence: `save_run_report`, `_save_operation_fingerprint` (both support optional `AtomicStateUpdate`)
- Display: `_display_sync_log`, `_create_mock_context`
- Test execution: `_parse_test_output` (multi-language), `_execute_tests_and_create_run_report` (supports multiple test files)
- Python coverage: `_python_cov_target_for_code_file`, `_python_cov_target_for_test_and_code` (analyze test imports for best `--cov` target)
- Example execution: `_detect_example_errors`, `_try_auto_fix_import_error`, `_run_example_with_error_detection` (handles server-style blocking examples)

## Error Handling

### Path Construction

Use `get_pdd_file_paths()` to resolve file paths. Handle errors gracefully:
- If `FileNotFoundError` mentions test files, construct default paths and continue (test will be generated)
- For other path errors, return error dict immediately with clear message

### Cycle Detection

Detect and break infinite loops with these limits:
- Auto-deps: 2+ occurrences in last 3 operations â†’ force advance to generate
- Crash-verify alternation: Break after 2 cycles (pattern [crash, verify, crash, verify])
- Test-fix alternation: Break after 2 cycles (pattern [test, fix, test, fix])
- Consecutive fix operations: Break after 5
- Consecutive test operations: Break after `MAX_CONSECUTIVE_TESTS` (3)
- Consecutive crash operations: Break after `MAX_CONSECUTIVE_CRASHES` (3) - Bug #157 fix
- Consecutive test_extend operations: Break after `MAX_TEST_EXTEND_ATTEMPTS` (2) and accept current coverage

### Budget and Lock Management

- Stop workflow if `total_cost >= budget`
- Log budget warnings when < 20% remaining
- Use `SyncLock` context manager; always release on exit
- Log lock_acquired and lock_released events

### Subprocess Isolation

For test execution and example runs:
- Remove TUI environment variables (`FORCE_COLOR`, `COLUMNS`)
- Use `start_new_session=True` to isolate from TUI terminal control
- Use `stdin=subprocess.DEVNULL` to prevent blocking

### Return Value Parsing

Handle command results in multiple formats:
- Dict: Extract `success`, `cost`, `model` fields directly
- Tuple: Cost is second-to-last element, model is last element
- Save fingerprint after successful operations regardless of format

## Constants

```python
MAX_CONSECUTIVE_TESTS = 3
MAX_TEST_EXTEND_ATTEMPTS = 2
MAX_CONSECUTIVE_CRASHES = 3
MAX_CYCLE_REPEATS = 2  # Inside sync_worker_logic()
```

## Classes

### AtomicStateUpdate

Context manager for atomic state updates (Issue #159 fix):
- `__init__(basename, language)` - Initialize with module info
- `set_run_report(report, path)` - Buffer run report for atomic write
- `set_fingerprint(fingerprint, path)` - Buffer fingerprint for atomic write
- `_atomic_write(data, target_path)` - Write via temp file + `os.replace()`
- `_commit()` - Write all buffered state on successful exit
- `_rollback()` - Clean up temp files on exception
