% You are an expert Python engineer. Your goal is to write a Python function, 'cmd_test_main', that will be the CLI wrapper for generating or enhancing unit tests. This function will read a prompt file and a code file, generate unit tests using `generate_test`, or enhance existing tests using `increase_tests` when a coverage report is provided, and handle the output location and language detection via `construct_paths`.

<include>./context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object containing CLI options and parameters. This object provides 'verbose', 'strength', 'temperature', 'time' (defaulting to `DEFAULT_TIME`), as well as 'force' and 'quiet' via `ctx.obj`.
        - `prompt_file` - A string containing the path to the prompt file that generated the code.
        - `code_file` - A string containing the path to the code file to be tested.
        - `output` - An optional string containing the path where to save the generated test file. If None, use the resolved path from `construct_paths`.
        - `language` - An optional string specifying the programming language. If None, deduce via `construct_paths`.
        - `coverage_report` - An optional string path to a coverage report. When provided, 'existing_tests' is required and `increase_tests` is used.
        - `existing_tests` - An optional string path to an existing test file. Required when using 'coverage_report'. If `merge` is True, output is written to this path.
        - `target_coverage` - An optional float indicating desired coverage. Accepted but not used by the current implementation.
        - `merge` - An optional boolean. If True and 'existing_tests' is provided, write output to 'existing_tests'.
    Outputs:
        - Returns a tuple containing (`str`, `float`, `str`):
            - `str`: The generated unit test code.
            - `float`: The total cost of the operation.
            - `str`: The name of the model used.

% Behavior:
%  - Build input and output paths, and determine language using `construct_paths`, passing:
%      input_file_paths: {prompt_file, code_file, and optionally coverage_report, existing_tests}
%      command_options: {output, language, merge, target_coverage}
%      along with ctx.obj['force'], ctx.obj['quiet'], and command="test".
%      When calling `construct_paths`, include `context_override=ctx.obj.get('context')` so a global `--context` is honored.
%  - If 'coverage_report' is NOT provided: call `generate_test(prompt, code, strength, temperature, time, language, verbose)`.
%  - If 'coverage_report' IS provided: require 'existing_tests'; otherwise print a Rich error and `ctx.exit(1)`. If provided, call
%    `increase_tests(existing_unit_tests, coverage_report, code, prompt_that_generated_code, language, strength, temperature, time, verbose)`.
%  - Use `ctx.obj.get('time', DEFAULT_TIME)` where `DEFAULT_TIME` is imported from `pdd.__init__`; `time` is a float in [0.0–1.0] representing relative thinking time.
%  - Validate generated content is non-empty after stripping; on empty, print diagnostics and `ctx.exit(1)`.
%  - Resolve output path:
%      * If `output` is None, or is a directory path or ends with '/', write to the resolved file from `construct_paths`.
%      * If `merge` is True and `existing_tests` is provided, write to `existing_tests`.
%      * Ensure parent directories exist and write with UTF-8 encoding.
%  - On any error (path construction, generation, postprocess, or file I/O), print a Rich-formatted error and call `ctx.exit(1)`.

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `generate_test` function (note: `time` is a float in [0–1]):
      <generate_test_example>
      <include>context/generate_test_example.py</include>
      </generate_test_example>

      - Here is how to increase coverage for the `test --coverage-report` sub-command using the `increase_tests` function (note: `time` is a float in [0–1]).
        <increase_tests_example>
        <include>context/increase_tests_example.py</include>
        </increase_tests_example>
   </internal_example_modules>
</examples>

% Here is the README for the cli command that has details of how the 'test' command works. Be sure to support the necessary global options like verbose, strength, temperature, and time (retrieved from `ctx.obj.get('time', DEFAULT_TIME)`, where `DEFAULT_TIME` is a float in [0.0–1.0]) when calling the `generate_test` and `increase_tests` functions. Also pass `force` and `quiet` to `construct_paths`.
   <cli_command_readme>
   <include>./README.md</include>
   </cli_command_readme>
