% You are an expert Python engineer. Your goal is to write the `trace_main` function that will be part of the `pdd` command-line program. This function will handle the core logic for the `trace` command.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
    - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
    - `prompt_file` (`str`): Path to the prompt file.
    - `code_file` (`str`): Path to the generated code file.
    - `code_line` (`int`): Line number in the code file to trace back to the prompt.
    - `output` (`Optional[str]`): Path to save the trace analysis results.

    Outputs:
    - Returns a tuple containing (`str`, `float`, `str`):
      - `str`: The line number in the prompt file corresponding to the code line.
      - `float`: The total cost of the operation.
      - `str`: The name of the model used.

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `trace` function:
      <trace_example>
      ```python
      from pdd.trace import trace # Assuming pdd.trace is the correct module path

      # Example usage of the trace function
      code_content = """
      def hello_world():
          print("Hello, PDD!") # Line 2
      """
      code_line_to_trace = 2
      prompt_content = """
      % Create a Python function that prints "Hello, PDD!".
      """
      strength = 0.5
      temperature = 0.0
      time_limit = 60.0 # Example time limit in seconds, e.g., DEFAULT_TIME

      try:
          # Assuming the trace function signature is now trace(code, code_line, prompt, strength, temperature, time)
          prompt_line, total_cost, model_name = trace(
              code_content, code_line_to_trace, prompt_content, strength, temperature, time_limit
          )
          if prompt_line:
              print(f"The code on line {code_line_to_trace} corresponds to prompt line: {prompt_line}")
              print(f"Total cost: ${total_cost:.6f}")
              print(f"Model used: {model_name}")
          else:
              print("Could not trace the code line to the prompt.")
      except Exception as e:
          print(f"An error occurred: {e}")
      ```
      </trace_example>
   </internal_example_modules>
</examples>

% The function should perform the following steps:
   1. **Construct File Paths**:
      - Use the `construct_paths` function to determine the input and output file paths.
      - Ensure that existing files are handled appropriately based on the `--force` and `--quiet` options.

   2. **Load Input Files**:
      - Read the contents of `prompt_file` and `code_file`.
      - Handle any file reading exceptions and provide informative error messages.

   3. **Perform Trace Analysis**:
      - Retrieve `strength = ctx.obj.get('strength', DEFAULT_STRENGTH)`, `temperature = ctx.obj.get('temperature', DEFAULT_TEMPERATURE)`, and `time = ctx.obj.get('time', DEFAULT_TIME)`. (Assuming DEFAULT_STRENGTH, DEFAULT_TEMPERATURE, and DEFAULT_TIME are defined constants or will be handled by Click).
      - Call the `trace` function with the contents of the code and prompt files, along with the `code_line`, `prompt_content`, `strength`, `temperature`, and `time`.
      - Capture the returned prompt line (`str`), total cost (`float`), and model name (`str`).

   4. **Save Results**:
      - Write the trace analysis results to a file if `output` is specified.
      - Include the total cost and model name in the output.

   5. **Provide User Feedback**:
      - Use `rprint` from the Rich library to display messages to the user, indicating success or failure.
      - Respect the verbosity levels determined by the `--quiet` option.

   6. **Error Handling**:
      - Wrap the main logic in a `try-except` block.
      - Catch exceptions, display error messages using `rprint`, and exit gracefully using `ctx.exit(1)` if necessary.

% Ensure that the function adheres to the existing codebase's coding style, including proper typing annotations, docstrings, and exception handling.
