% You are an expert Python engineer. Your goal is to write a Python function, 'code_generator_main', that will be the CLI wrapper for generating code from prompts. This function will read a prompt file, generate code using the code_generator or incremental_code_generator function, and handle the output location.

<include>./context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
   Inputs:
      - `ctx` (`click.Context`): The Click context object containing CLI options (e.g., temperature, strength, etc.) and parameters. The `time` parameter (e.g., a time budget in seconds) is retrieved from `ctx.obj.get('time', DEFAULT_TIME)`.
      - 'prompt_file' - A string containing the path to the prompt file to generate code from.
      - 'output' - An optional string containing the path where to save the generated code. If None, uses default naming convention.
      - 'original_prompt' - An optional string containing the path to the original prompt file used for incremental generation. If None, attempts to use git to find the last committed version.
      - 'incremental' - A boolean that forces the use of incremental patching even if the diff analyzer suggests full regeneration. Default is False.
   Outputs:
      - Returns a tuple containing (`str`, `bool`, `float`, `str`):
            - `str`: The generated or updated code.
            - `bool`: Whether the operation was incremental (True) or a full regeneration (False).
            - `float`: The total cost of the operation.
            - `str`: The name of the model used.

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>
      % When `construct_paths` is called with `command_options` (e.g., `{'output': output_value}`),
      % the resolved path for that option will be available in the returned `output_file_paths` dictionary
      % under the *same key* used in `command_options` (e.g., `output_file_paths.get('output')`).

      - Here is an example of how to use the `code_generator` function:
      <code_generator_example>
      ```python
      from pdd.code_generator import code_generator # Assuming pdd.code_generator is the path
      # from .code_generator import code_generator # Or relative if used within the same package context

      prompt_content = "Create a Python function that adds two numbers and returns the sum."
      language = "python"
      strength = 0.5
      temperature = 0.2
      time_budget = 60  # Example time budget in seconds, e.g., DEFAULT_TIME
      verbose = True

      generated_code, cost, model_name = code_generator(
          prompt=prompt_content,
          language=language,
          strength=strength,
          temperature=temperature,
          time=time_budget, # Pass the time budget
          verbose=verbose
      )

      print(f"Generated Code:\n{generated_code}")
      print(f"Cost: ${cost:.6f}, Model: {model_name}")
      ```
      </code_generator_example>
      
      - Here is an example of how to use the `incremental_code_generator` function:
      <incremental_code_generator_example>
      ```python
      from pdd.incremental_code_generator import incremental_code_generator # Assuming pdd.incremental_code_generator is the path
      # from .incremental_code_generator import incremental_code_generator # Or relative

      original_prompt_content = "def greet():\n    print('Hello World')"
      new_prompt_content = "def greet(name):\n    print(f'Hello, {name}!')"
      existing_code_content = "def greet():\n    print('Hello World')"
      language = "python"
      strength = 0.6
      temperature = 0.1
      time_budget = 120  # Example time budget in seconds
      force_incremental_flag = False
      verbose_flag = True
      should_preprocess_prompt = True # Typically True for incremental

      generated_code, was_incremental, cost, model_name = incremental_code_generator(
          original_prompt=original_prompt_content,
          new_prompt=new_prompt_content,
          existing_code=existing_code_content,
          language=language,
          strength=strength,
          temperature=temperature,
          time=time_budget, # Pass the time budget
          force_incremental=force_incremental_flag,
          verbose=verbose_flag,
          preprocess_prompt=should_preprocess_prompt
      )

      print(f"Generated Code:\n{generated_code}")
      print(f"Was Incremental: {was_incremental}, Cost: ${cost:.6f}, Model: {model_name}")
      ```
      </incremental_code_generator_example>

      - Here is an example of how to use the `get_jwt_token` function to get the JWT_TOKEN:
      <get_jwt_token_example>
      <include>context/get_jwt_token_example.py</include>
      </get_jwt_token_example>
      % The `get_jwt_token` function is an async function and must be run with `asyncio.run`.
      % The implementation expects environment variables `NEXT_PUBLIC_FIREBASE_API_KEY` and `GITHUB_CLIENT_ID` to be set
      % and passes them to `get_jwt_token(firebase_api_key=..., github_client_id=..., app_name="PDD Code Generator")`.

      - Here is an example of how to use the `preprocess` function:
      <preprocess_example>
      <include>context/preprocess_example.py</include>
      </preprocess_example>

   </internal_example_modules>

   % Here is how to call the cloud version of the code generator when not using the `--local` flag.
   % Note: The API documentation (represented by the included api-documentation.md) should reflect that
   % the JSON request payload to the cloud service can include a 'timeBudget' (or similar 'time'/'effort')
   % field if the API supports it, corresponding to the 'time' parameter from the CLI.
   <cloud_code_generator_example>
      <include>../docs/api-documentation.md</include>
   </cloud_code_generator_example>
</examples>

% Here is the README for the cli command that has details of how the 'generate' command works:
   <cli_command_readme>
      <include>./README.md</include>
   </cli_command_readme>

% Cloud vs Local Execution Strategy:
   1. If the `--local` flag is explicitly provided, use local execution directly.
   2. Otherwise, attempt cloud execution first:
      - Preprocess the prompt using the `preprocess` function with `recursive=True` and `double_curly_brackets=True`.
      - Obtain a JWT via `get_jwt_token` using `NEXT_PUBLIC_FIREBASE_API_KEY` and `GITHUB_CLIENT_ID`.
      - Use a request timeout of 400 seconds.
      - Send JSON payload with fields: `{ "promptContent": <processed prompt>, "language": <language>, "strength": <strength>, "temperature": <temperature>, "verbose": <verbose> }`.
        % Note: A time/effort field (e.g., `timeBudget`) is not currently sent; include only if/when the API supports it.
      - Cloud endpoint: `https://us-central1-prompt-driven-development.cloudfunctions.net/generateCode`
      - Expected response fields: `generatedCode`, `totalCost`, `modelName`.
   3. If cloud execution fails (auth/network/HTTP/JSON errors, timeout, or missing code):
      - Log a warning and automatically fall back to local execution.
   4. For local execution, call the local code generator with `preprocess_prompt=True`.
   5. For both modes, if `verbose` is true, print relevant execution information using Rich panels.

% The function handles incremental code generation:
    1. If an output location is provided and the file exists, attempt incremental generation if:
       - The original prompt is specified explicitly via the `--original-prompt` parameter; or
       - The prompt file is tracked in git. If the on-disk prompt differs from `HEAD`, use `HEAD` as the original; if it matches `HEAD`, search recent history (up to ~10 commits) for a prior different version and use it if found; otherwise fall back to `HEAD` with a warning.
    2. Before calling the incremental generator, stage with `git add` only those files (prompt/output) that are untracked or differ from `HEAD` to aid rollback.
    3. Always perform full generation via the code_generator function if:
       - No output location is provided, or
       - The output file doesn't exist, or
       - We can't get the original prompt (no --original-prompt and not in git)
       - The incremental_code_generator returns is_incremental=False indicating a full regeneration is needed
    4. Force incremental generation if the --incremental flag is set, but warn if no output file exists and do full generation

% The function's implementation should include these key steps:
    1. Retrieve `strength`, `temperature`, and `time` from `ctx.obj` using defaults (e.g., `time = ctx.obj.get('time', DEFAULT_TIME)`).
    2. Process the prompt_file (read content; for cloud, preprocess with `recursive=True` and `double_curly_brackets=True`; for local/incremental, let the generator handle preprocessing via `preprocess_prompt=True`).
    3. Determine the language using `construct_paths` (may infer from file extension, special cases, or filename suffix).
    4. Determine whether to use incremental generation or full generation:
       - Check if output is specified and file exists
       - If original_prompt is specified, use it; otherwise try to get last committed version from git
       - If both conditions met, try incremental generation
    5. For incremental generation:
       - Read the existing code from the output file
       - Read original prompt content (from specified file or git)
       - Stage prompt_file and output file with git (if they aren't already staged/committed)
       - Call incremental_code_generator with appropriate parameters (including `strength`, `temperature`, and `time` from `ctx.obj`)
       - If incremental_code_generator returns is_incremental=False, fall back to full generation
    6. For full generation:
       - Call code_generator (local version) with appropriate parameters (including `strength`, `temperature`, and `time` from `ctx.obj`). For cloud execution, ensure the `time` (or equivalent like `timeBudget`) is included in the API payload if supported.
       - If cloud execution fails, automatically fall back to local execution with appropriate warnings
    7. Write the final code to the output location:
       - If `--output` ends with a path separator or points to a directory, use the resolved default filename from `construct_paths`.
       - If no output is provided, print the generated code to the console (when not in quiet mode).
    8. Return the generated code, incremental flag, cost, and model name
