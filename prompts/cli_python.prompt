<context>
% You are an expert Python engineer. Your goal is to write a Python command-line program, `pdd`. The command-line interface will be handled using the Python Click library. It will contain the `cli` function.
</context>

<include>context/python_preamble.prompt</include>

% Here is a detailed description of the program functionality:
    <program_description>
    <include>./README.md</include>
    </program_description>

% Directory structure of the program:
    - `pdd/pdd/*.py` (including `cli.py` and command modules)
    - `pdd/prompts`
    - `pdd/context`
    - `pdd/data`

<examples>
    % Here is how to use the Python Click library to create a command line program:
    <click_example>
    <include>context/click_example.py</include>
    </click_example>
</examples>

<instructions>
    % Examples of using internal modules:

    <internal_example_modules>
        - The 'auto_update' function will be used to check if pdd is up to date if `PDD_AUTO_UPDATE` is not set or is True. Here is an example of how to use the 'auto_update' function:
        <auto_update_example>
        <include>context/auto_update_example.py</include>
        </auto_update_example>

        - The `track_cost` decorator has already been defined in another module. Here is an example of how to use the `track_cost` decorator:
        <track_cost_example>
        <include>./context/track_cost_example.py</include>
        </track_cost_example>

        - `change` command: The core logic is implemented in the `change_main` function, defined in a separate module. Here's how to use `change_main`:
        <change_main_example>
        <include>context/change_main_example.py</include>
        </change_main_example>

        - `generate` command: To generate runnable code from a prompt file, use `code_generator_main`. Here is an example of how to generate code from the prompt from a file:
        <code_generator_example>
        <include>context/code_generator_main_example.py</include>
        </code_generator_example>

        - `example` command: To generate example code from a code file, use `context_generator_main`. Here is an example of how to generate an example from a code file:
        <context_generator_example>
        <include>context/context_generator_main_example.py</include>
        </context_generator_example>

        - `test` command: To generate or to increase coverage of a unit test from code and its prompt file, use `cmd_test_main`. Here is an example of how to generate/increase coverage of  a unit test from a code file:
        <generate_test_example>
        <include>context/cmd_test_main_example.py</include>
        </generate_test_example>

        - `preprocess` command: The core logic is implemented in the `preprocess_main` function, defined in a separate module. Here's how to use `preprocess_main`:
        <preprocess_main_example>
        <include>context/auto_deps_main_example.py</include>
        </preprocess_main_example>

        - `fix` command: To fix errors in code and unit tests, use `fix_main`. Here is an example of how to fix errors in code and unit tests:
        <fix_errors_from_unit_tests_example>
        <include>context/fix_main_example.py</include>
        </fix_errors_from_unit_tests_example>

        - `split` command: To split a prompt file into multiple prompt files, use the `split_main` function. Here is an example of how to split a prompt file into multiple prompt files:
        <split_main_example>
        <include>context/split_main_example.py</include>
        </split_main_example>

        - `update` command and related sub-commands: To update the prompt file, use the `update_main` function. Here is an example of how to update the prompt file:
        <update_prompt_example>
        <include>context/update_main_example.py</include>
        </update_prompt_example>

        - `detect` command: To analyze a list of prompt files and a change description to determine which prompts need to be changed, use the `detect_change_main` function. Here is an example of how to detect prompts that need changes:
        <detect_change_example>
        <include>context/detect_change_main_example.py</include>
        </detect_change_example>

        - `conflicts` command: To analyze two prompt files to find conflicts between them and suggest how to resolve those conflicts, use the `conflicts_main` function. Here is an example of how to use the `conflicts_main` function:
        <conflicts_main_example>
        <include>context/conflicts_main_example.py</include>
        </conflicts_main_example>

        - `crash` command and related sub-commands: To fix errors in a code module that caused a program to crash, use the `crash_main` function. Here is an example of how to fix errors in a code module that caused a program to crash:
        <crash_main_example>
        <include>context/crash_main_example.py</include>
        </crash_main_example>

        - `trace` command: The core logic is implemented in the `trace_main` function, which is defined in a separate module. Here is an example of how to use the `trace_main` function:
        <trace_main_example>
        <include>context/trace_main_example.py</include>
        </trace_main_example>

        - `bug` command: To create a unit test from a bug in a code module, use the `bug_main` function. Here is an example of how to create a unit test from a bug in a code module:
        <bug_to_unit_test_example>
        <include>context/bug_main_example.py</include>
        </bug_to_unit_test_example>

        - `auto-deps` command: The core logic is implemented in the `auto_deps_main` function, defined in a separate module. Be sure to strip quotes from directory_path path if present before calling `auto_deps_main`. Here's how to use `auto_deps_main`:
        <auto_deps_main_example>
        <include>context/auto_deps_main_example.py</include>
        </auto_deps_main_example>
 
        - `verify` command: The core logic is implemented in the `fix_verification_main` function, defined in a separate module. This command verifies functional correctness of generated code by executing a specified program and using an LLM to judge the program's output against the original prompt's intent. Here's how to use `fix_verification_main`:
        <verify_main_example>
        <include>context/fix_verification_main_example.py</include>
        </verify_main_example>
        
        - `install_completion` command: The core logic is implemented in the `install_completion` function, defined in a separate module. Here's how to use `install_completion` and `get_local_pdd_path`:
        <install_completion_example>
        <include>context/install_completion_example.py</include>
        </install_completion_example>
        % 
    </internal_example_modules>

    % Ensure consistency across commands, following shared coding standards and documentation practices.
</instructions>