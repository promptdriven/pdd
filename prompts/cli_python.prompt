
<example_generation>
% Here an example of a prompt and generated code from a prior version of the below prompt:
    <prior_prompt><include>context/generate/4/cli_python.prompt</include></prior_prompt>
    <prior_code><include>context/generate/4/cli.py</include></prior_code>
</example_generation>

<context>
% You are an expert Python engineer. Your goal is to write a Python command-line program, `pdd`. The command-line interface will be handled using the Python Click library. It will contain the `cli` function.
</context>

<include>context/python_preamble.prompt</include>

% Here is a detailed description of the program functionality:
    <program_description>
    <include>./README.md</include>
    </program_description>

% Directory structure of the program:
    - `pdd/pdd/*.py` (including `cli.py` and command modules)
    - `pdd/prompts`
    - `pdd/context`
    - `pdd/data`

<examples>
    % Here is how to use the Python Click library to create a command line program:
    <click_example>
    <include>context/click_example.py</include>
    </click_example>
</examples>

<instructions>
    % To avoid name conflicts, import functions with aliases. Ensure module names match imported function names.

    % Examples of using internal modules:

    <internal_example_modules>
        - The 'auto_update' function will be used to check if pdd is up to date. Here is an example of how to use the 'auto_update' function:
        <auto_update_example>
        <include>context/auto_update_example.py</include>
        </auto_update_example>

        - The `track_cost` decorator has already been defined in another module. Here is an example of how to use the `track_cost` decorator:
        <track_cost_example>
        <include>./context/track_cost_example.py</include>
        </track_cost_example>

        - Here is how to use the `construct_paths` function to load the input files and create the output file paths:
        <construct_paths_example>
        <include>context/construct_paths_example.py</include>
        </construct_paths_example>

        - `change` command: The core logic is implemented in the `change_main` function, defined in a separate module. Here's how to use `change_main`:
        <change_main_example>
        <include>context/change_main_example.py</include>
        </change_main_example>

        - `generate` command: To generate runnable code from a prompt file, use `code_generator_main`. Here is an example of how to generate code from the prompt from a file:
        <code_generator_example>
        <include>context/code_generator_main_example.py</include>
        </code_generator_example>

        - `example` command: To generate example code from a code file, use `context_generator_main`. Here is an example of how to generate an example from a code file:
        <context_generator_example>
        <include>context/context_generator_main_example.py</include>
        </context_generator_example>

        - `test` command: To generate or to increase coverage of a unit test from code and its prompt file, use `cmd_test_main`. Here is an example of how to generate/increase coverage of  a unit test from a code file:
        <generate_test_example>
        <include>context/cmd_test_main_example.py</include>
        </generate_test_example>

        - `preprocess` command: The core logic is implemented in the `preprocess_main` function, defined in a separate module. Here's how to use `preprocess_main`:
        <preprocess_main_example>
        <include>context/auto_deps_main_example.py</include>
        </preprocess_main_example>

        - `fix` command: To fix errors in code and unit tests, use `fix_main`. Here is an example of how to fix errors in code and unit tests:
        <fix_errors_from_unit_tests_example>
        <include>context/fix_main_example.py</include>
        </fix_errors_from_unit_tests_example>

        - `split` command: To split a prompt file into multiple prompt files, use the `split_main` function. Here is an example of how to split a prompt file into multiple prompt files:
        <split_main_example>
        <include>context/split_main_example.py</include>
        </split_main_example>

        - `update` command and related sub-commands: To update the prompt file, use the `update_main` function. Here is an example of how to update the prompt file:
        <update_prompt_example>
        <include>context/update_main_example.py</include>
        </update_prompt_example>

        - `detect` command: To analyze a list of prompt files and a change description to determine which prompts need to be changed, use the `detect_change_main` function. Here is an example of how to detect prompts that need changes:
        <detect_change_example>
        <include>context/detect_change_main_example.py</include>
        </detect_change_example>

        - `conflicts` command: To analyze two prompt files to find conflicts between them and suggest how to resolve those conflicts, use the `conflicts_main` function. Here is an example of how to use the `conflicts_main` function:
        <conflicts_main_example>
        <include>context/conflicts_main_example.py</include>
        </conflicts_main_example>

        - `crash` command and related sub-commands: To fix errors in a code module that caused a program to crash, use the `crash_main` function. Here is an example of how to fix errors in a code module that caused a program to crash:
        <crash_main_example>
        <include>context/crash_main_example.py</include>
        </crash_main_example>

        - `trace` command: The core logic is implemented in the `trace_main` function, which is defined in a separate module. Here is an example of how to use the `trace_main` function:
        <trace_main_example>
        <include>context/trace_main_example.py</include>
        </trace_main_example>

        - `bug` command: To create a unit test from a bug in a code module, use the `bug_to_unit_test` function. Here is an example of how to create a unit test from a bug in a code module:
        <bug_to_unit_test_example>
        <include>context/bug_to_unit_test_example.py</include>
        </bug_to_unit_test_example>

        - `auto-deps` command: The core logic is implemented in the `auto_deps_main` function, defined in a separate module. Here's how to use `auto_deps_main`:
        <auto_deps_main_example>
        <include>context/auto_deps_main_example.py</include>
        </auto_deps_main_example>
 
    </internal_example_modules>

    % For the `trace` command in the `cli` function:
        - Define the `trace` command using the `@cli.command()` decorator.
        - Include the necessary arguments and options.
        - Decorate the command function with `@track_cost` to enable cost tracking.
        - The `trace` command function should be a thin wrapper that calls `trace_main`, passing all necessary parameters.

    % `install_completion` command: Enhance the shell completion installation process by determining the correct paths for different shells and ensuring the source command is added to the shell's RC file only if it's not already present. Use a helper function to manage these paths.

    % For the `update` command:
        - Modify the command to accept an optional `input_code_file` argument.
        - Add a `--git` flag option to use git history for finding the original code file.
        - Update the command logic to handle both cases: with and without the `--git` flag.
        - When using git, call the `git_update` function instead of `update_prompt`.
        - Ensure proper error handling and user feedback for both cases.

    % For the `change` command in the `cli` function:
        - Define the command using `@cli.command()`.
        - Include necessary arguments and options.
        - Decorate with `@track_cost` to enable cost tracking.
        - The command function should be a thin wrapper that calls `change_main`, passing all required parameters.

    % Ensure consistency across commands, following shared coding standards and documentation practices.
</instructions>