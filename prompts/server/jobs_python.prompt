% You are an expert Python engineer. Your goal is to write `pdd/server/jobs.py`.

% Role & Scope
  This module provides job queue management for async command execution.
  It handles job submission, tracking, execution, and cancellation
  with support for concurrent job limits and WebSocket streaming integration.

<include>context/python_preamble.prompt</include>

% Documentation References
  - asyncio: https://docs.python.org/3/library/asyncio.html
  - asyncio.Semaphore: https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore
  - concurrent.futures: https://docs.python.org/3/library/concurrent.futures.html
  - ThreadPoolExecutor: https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor

% Requirements
  1. **Job dataclass**:
     - id: UUID string
     - command: str (e.g., "sync", "generate")
     - args: Dict[str, Any]
     - options: Dict[str, Any]
     - status: JobStatus enum
     - result: Optional[Any]
     - error: Optional[str]
     - cost: float
     - created_at, started_at, completed_at: datetime
     - to_dict() method for JSON serialization

  2. **JobManager class**:
     - __init__(max_concurrent=1, executor=None)
     - submit(command, args, options) -> Job: Queue a new job
     - get_job(job_id) -> Optional[Job]
     - get_all_jobs() -> Dict[str, Job]
     - get_active_jobs() -> Dict[str, Job]: Running or queued
     - cancel(job_id) -> bool: Attempt to cancel
     - cleanup_old_jobs(max_age_seconds) -> int: Remove old completed jobs
     - shutdown() -> None: Cancel all and cleanup

  3. **Execution control**:
     - Use asyncio.Semaphore for concurrency limit
     - Jobs run in background via asyncio.create_task()
     - Support cancellation via asyncio.Event
     - Execute Click commands via ClickCommandExecutor

  4. **Callback integration**:
     - on_start, on_output, on_progress, on_complete callbacks
     - Used by WebSocket routes for streaming
     - Async callback functions

  5. **Error handling**:
     - Catch exceptions during execution
     - Set job.error and job.status = FAILED
     - Never leave job in RUNNING state after error

  6. **Thread safety**:
     - Safe for concurrent access from multiple requests
     - Use locks where needed

% Dependencies
  <job_manager_example>
  <include>context/job_manager_example.py</include>
  </job_manager_example>
  <models_note>
  Use JobStatus enum from pdd/server/models.py
  </models_note>

% Instructions
  - Use dataclass for Job (not Pydantic - internal only)
  - JobManager should be singleton-like (one per app)
  - Default executor calls ClickCommandExecutor
  - Store jobs in memory (Dict[str, Job])
  - Cancel event per job for cooperative cancellation

% Deliverables
  - Code: `pdd/server/jobs.py`
  - Export: Job, JobManager, JobCallbacks
