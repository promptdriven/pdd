% You are an expert Python software engineer. Your goal is to write a Python function, "construct_paths", that will generate and check the appropriate input and output file paths, handle specific file requirements, and then load the input files.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
    - 'input_file_paths' (dict) - A dictionary to the paths of the input files with the keys being those specified in the examples from the pdd program description. For example, the 'generate' command has the 'prompt_file' key, 'example' has 'code_file' key, etc. Additionally, handle an 'error_file' key.
    - 'force' (boolean) - A flag that indicates whether to overwrite the output files if they already exist.
    - 'quiet' (boolean) - A flag that indicates whether to suppress the output.
    - 'command' (string) - pdd command that was run. Supported commands include: 'generate', 'example', 'test', 'preprocess', 'fix', 'split', 'change', 'update', 'detect', 'conflicts', 'crash', 'trace', 'bug', 'auto-deps', 'verify', 'sync'.
    - 'command_options' (dict) - A dictionary of the command options for the given command. For example, it could have the 'language' key for the 'test' command or output locations for other commands.
    - 'create_error_file' (boolean, optional, default: True) - A flag that indicates whether to create the error file if it does not exist.
    - 'context_override' (string, optional, default: None) - A flag to manually specify the .pddrc context to use, overriding automatic detection.
    Outputs: A tuple containing:
    - 'input_strings' (dict) - A dictionary with the keys being the pdd description examples and the values being the input file strings. Include all existing files, including error files.
    - 'output_file_paths' (dict[str, str])- A dictionary where keys are identifiers for output files (e.g., 'output_file', 'debug_file') and values are their absolute string paths.
    - 'language' (string) - The language of the output file.

% Here is a detailed description of the program functionality: <program_description><include>README.md</include></program_description>

% Here are examples of how to use internal modules:
<internal_example_modules>
    % Here is an example of how to lookup a file extension given a language: <get_extension_example><include>context/get_extension_example.py</include></get_extension_example>

    % Here is an example of how to lookup a language given a file extension: <get_language_example><include>context/get_language_example.py</include></get_language_example>

    % Here is how to generate the output paths: <generate_output_paths_example><include>context/generate_output_paths_example.py</include></generate_output_paths_example>    
</internal_example_modules>

% Use get_extension to get the file extension for the language. When checking if an extension can be determined, pass an empty string ("") instead of None to the get_extension function. The file extension and language is used for the subsequent functionality below.

% The known languages of the pdd system can be found at $PDD_PATH/data/language_format.csv which has the following columns: language,comment,extension. Ensure that PDD_PATH environment variable is set and the language_format.csv file exists, raising appropriate errors (e.g., ValueError, FileNotFoundError) if not when accessing it.

% Unless quiet is True, print out the input and output file paths that are being used and the steps being done below.

% This function will do the following:
    Step 1. Configuration Resolution. This function must implement a hierarchical configuration system as described in `README.md`. The hierarchy of settings should be: 1. CLI options (`command_options`), 2. `.pddrc` context-specific settings, 3. Environment variables, 4. Built-in defaults.
        - **1a. .pddrc Loading:** Find a `.pddrc` file by searching upwards from the current directory. If found, load the YAML configuration. Handle potential parsing errors gracefully.
        - **1b. Context Detection:** Based on the current working directory, determine the active context from the `contexts` section of the `.pddrc` file using the `paths` patterns. The `context_override` input parameter should take precedence if provided. If no specific context is matched, use the `default` context if it exists.
        - **1c. Hierarchy Application:** Resolve the final configuration for settings (like output paths, language, model parameters, etc.) by applying the priority order. The `command_options` dictionary should be updated in-place with the results of this resolution, ensuring that CLI options provided by the user are not overridden. The resolved context configuration should be stored for later use.
    Step 2. Resolve input paths to absolute paths. For non-error files, ensure they exist strictly. For error files, resolve non-strictly. Then, load all existing input files into the input_strings dictionary using the 'input_file_paths' dictionary with the pdd description examples as the keys. For error files, conditionally create them if they don't exist based on `create_error_file`; if they do exist (or are created), load them like any other file. Alert the user and raise appropriate exceptions (e.g., `FileNotFoundError`, `IOError`) for path or reading issues.
    Step 3. Extract out the basename from the input file path. This involves:
        - Prioritizing specific input files based on the `command` (e.g., `prompt1`/`prompt2` for `conflicts`, `change_file` for `detect`, `change_prompt_file` for `change`, `prompt_file` for commands like `sync` that work with specific prompt files).
        - For prompt-based basenames, identifying the primary prompt file.
        - Stripping known language suffixes (e.g., `_python`) from the file stem, where known languages are defined in `$PDD_PATH/data/language_format.csv`.
        - Handling cases where no explicit prompt is found by using a fallback input file.
        - Raising a `ValueError` if a basename cannot be determined.
    Step 4. Determine the language (see Step B for details). Then, construct the output file paths using the "generate_output_paths" function. Be sure to remove non-output keys from the `command_options` dictionary before passing its relevant items to the "generate_output_paths" function's `output_locations` parameter. The resolved context configuration from Step 1 should also be passed to `generate_output_paths`. The returned dictionary of paths from `generate_output_paths` should have string values, and these string paths are what `construct_paths` should return in `output_file_paths`. Implement a final safety fallback to a default language (e.g., 'python') if the determined language is invalid before getting the extension, logging a warning if not quiet.
    Step 5. If the output files already exist, and force isn't true, check with the user if the program should overwrite. Use click.style to style the confirmation message and click.secho for the cancellation message. When prompting for confirmation, set the default to True so pressing Enter will choose to overwrite. If the user presses 'n' or 'N' then exit the program. If the user presses enter, 'y' or 'Y' then overwrite the output files.
    Step 6. Return the 'input_strings', 'output_file_paths' (as a dictionary of string paths) and 'language'.

Follow these steps in this order:
    Step A. List out all the ways the basename can be extracted from the input file path for each of the commands. For example, the basename is usually the first input prompt file without the directory, language, or file extension. However, keep in mind for the 'detect' command, the change file determines the basename. For the 'sync' command, the basename comes from the `prompt_file` input after stripping language suffixes. For each way, in a paragraph, explain how the basename is extracted for each command, what are potential corner cases (like needing to validate language suffixes against `$PDD_PATH/data/language_format.csv`), and how to deal with them. This logic should carefully consider these rules.
    Step B. List out all the ways language can be extracted from the input file path or command_options. This logic should determine the language with the following priority:
        1. An explicit 'language' option from `command_options` (if provided and not None).
        2. Inferred from the file extension of code/test input files (using `get_language`).
        3. Parsed from a prompt filename suffix (e.g., `_python` in `my_prompt_python.prompt`), validated against known languages in `$PDD_PATH/data/language_format.csv`.
        4. A default language (e.g., "prompt") for specific commands like `detect`.
        If language cannot be determined through these means, raise a `ValueError`.
    Step C. Write out the construct_paths function.