
% You are an expert Python engineer. Your goal is to write a Python function, 'fix_main', that will be the CLI wrapper for fixing errors in code and unit tests. This function will handle the error fixing process using either the fix_errors_from_unit_tests function or fix_error_loop function depending on whether the --loop option is used.

<include>./context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
            Context parameters used:
            - strength (float): Model strength parameter, defaults to DEFAULT_STRENGTH
            - temperature (float): Model temperature parameter, defaults to 0
            - time (int): Model time parameter (e.g., timeout in seconds), defaults to DEFAULT_TIME
            - force (bool): Whether to force overwrite existing files
            - quiet (bool): Whether to suppress output messages
            - verbose (bool): Whether to enable verbose output for debugging purposes
        - `prompt_file` (str): The filename of the prompt file that generated the code under test.
        - `code_file` (str): The filename of the code file to be fixed.
        - `unit_test_file` (str): The filename of the unit test file.
        - `error_file` (str): The filename containing the unit test runtime error messages.
        - `output_test` (Optional[str]): Path where to save the fixed unit test file. If None, uses default naming convention.
        - `output_code` (Optional[str]): Path where to save the fixed code file. If None, uses default naming convention.
        - `output_results` (Optional[str]): Path where to save the results of the error fixing process. If None, uses default naming convention.
        - `loop` (bool): If True, enables iterative fixing process.
        - `verification_program` (Optional[str]): Path to Python program that verifies if code runs correctly. Only used with --loop.
        - `max_attempts` (int): Maximum number of fix attempts before giving up. Only used with --loop. Default is 3.
        - `budget` (float): Maximum cost allowed for fixing process. Only used with --loop. Default is $5.0.
        - `auto_submit` (bool): If True, automatically submits example if all unit tests pass during fix loop.

    Outputs:
        - Returns a tuple containing:
            - `bool`: Success status of the fix operation
            - `str`: The fixed unit test code
            - `str`: The fixed source code  
            - `int`: Total number of fix attempts made
            - `float`: Total cost of the operation
            - `str`: Name of the model used

% Important Implementation Notes:
1.  Parameter Retrieval:
    - Retrieve `strength = ctx.obj.get('strength', DEFAULT_STRENGTH)`.
    - Retrieve `temperature = ctx.obj.get('temperature', 0)`.
    - Retrieve `time = ctx.obj.get('time', DEFAULT_TIME)`. (Ensure DEFAULT_TIME is imported or defined)
    - Retrieve `verbose = ctx.obj.get('verbose', False)`.
    - Retrieve `force = ctx.obj.get('force', False)`.
    - Retrieve `quiet = ctx.obj.get('quiet', False)`.

2.  File Path Handling and Function Calls:
    - When calling `fix_error_loop`, pass the original file paths (`code_file` and `unit_test_file`), `prompt` content, `verification_program`, `strength`, `temperature`, `max_attempts`, `budget`, `time`, `error_log_file` (from `output_file_paths`), and `verbose` directly.
    - When calling `fix_errors_from_unit_tests`, use the processed input_strings from `construct_paths` for `unit_test`, `code`, `prompt`, and `error`. Pass `error_file` (from `output_file_paths`), `strength`, `temperature`, `time`, and `verbose`.
    - Handle both fixing approaches appropriately based on the `--loop` parameter.

3.  Error Handling Requirements:
    - Validate verification program:
        * Raise `click.UsageError` if `--loop` is used without `--verification-program`.
    - Handle file operations:
        * Use `try/except` blocks for file reading/writing.
        * Provide formatted error messages using `rich.print`.
    - Handle auto-submission errors:
        * Authentication errors.
        * API submission errors.
        * Missing environment variables.
    - Exit with `sys.exit(1)` on critical errors.

4.  Auto-submit Functionality:
    When `auto_submit` is True and the fix is successful:
    a) Authentication:
        - Get JWT token using `get_jwt_token()`.
        - Required environment variables:
            * `REACT_APP_FIREBASE_API_KEY`
            * `GITHUB_CLIENT_ID`
    b) Submission Payload:
        - Input files:
            * prompts (content and filename)
            * code (content and filename)
            * tests (content and filename)
            * errors (if available)
            * verification program (if specified)
        - Output files:
            * fixed code (content and filename)
            * fixed tests (content and filename)
            * analysis (if available)
        - Metadata:
            * title: "Auto-submitted fix for {filename}"
            * description: "Automatically submitted successful code fix"
            * language: detected from file extension
            * framework: ""
            * tags: ["auto-fix", "example"]
            * isPublic: True
            * price: 0.0
    c) Submit to endpoint:
        - URL: `https://us-central1-prompt-driven-development.cloudfunctions.net/submitExample`
        - Headers: Authorization with JWT token.
        - Handle response and provide user feedback.

5.  Verbose Output:
    - The `verbose` parameter (retrieved from `ctx`) should be passed to both `fix_error_loop` and `fix_errors_from_unit_tests` calls.
    - When `verbose` is True, these functions should provide additional debugging information during the fixing process.

6.  User Feedback:
    - Use `rich.print` for formatted output.
    - Show success/failure status.
    - Display total attempts and cost.
    - Show model name used.
    - List saved file paths.
    - Show auto-submit status if enabled.

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `fix_errors_from_unit_tests` function (updated to include `time`):
      <fix_errors_example>
      ```python
      from typing import Tuple, Optional
      from pdd.fix_errors_from_unit_tests import fix_errors_from_unit_tests # Assuming this is the correct import path

      # Example usage of fix_errors_from_unit_tests
      unit_test_content = """
      def test_example_fail():
          assert 1 == 0 # This will fail
      """
      code_content = """
      def example_function():
          return True
      """
      prompt_content = "Create a simple Python function and a test that fails."
      error_content = "AssertionError: assert 1 == 0"
      error_file_path = "temp_error_log.txt" # Path for the error log output by the function
      strength = 0.8
      temperature = 0.0
      time_limit = 300 # Example time limit in seconds

      try:
          # Create a dummy error_file_path if it's read by the function initially
          # or ensure the function handles its creation/appending.
          # For this example, we assume error_file is for output.
          
          update_unit_test, update_code, fixed_unit_test, fixed_code, analysis_results, total_cost, model_name = fix_errors_from_unit_tests(
              unit_test=unit_test_content,
              code=code_content,
              prompt=prompt_content,
              error=error_content,
              error_file=error_file_path, # This is where the function will write its analysis
              strength=strength,
              temperature=temperature,
              time=time_limit, # Pass the time parameter
              verbose=True
          )

          print(f"Update Unit Test: {update_unit_test}")
          print(f"Update Code: {update_code}")
          print(f"Fixed Unit Test:\n{fixed_unit_test}")
          print(f"Fixed Code:\n{fixed_code}")
          print(f"Analysis Results:\n{analysis_results}")
          print(f"Total Cost: ${total_cost:.6f}")
          print(f"Model Name: {model_name}")

      except Exception as e:
          print(f"An error occurred: {e}")
      ```
      </fix_errors_example>

      - Here is an example of how to use the `fix_error_loop` function (updated to include `time`):
      <fix_loop_example>
      ```python
      from typing import Tuple, Optional
      import os
      import tempfile
      from pdd.fix_error_loop import fix_error_loop # Assuming this is the correct import path

      # Create dummy files for the example
      temp_dir = tempfile.mkdtemp()
      unit_test_file_path = os.path.join(temp_dir, "test_example.py")
      code_file_path = os.path.join(temp_dir, "example_code.py")
      verification_program_path = os.path.join(temp_dir, "verify.py")
      error_log_path = os.path.join(temp_dir, "loop_error_log.txt")

      with open(unit_test_file_path, "w") as f:
          f.write("def test_always_fail():\n    assert False")
      with open(code_file_path, "w") as f:
          f.write("def my_function():\n    return 1")
      with open(verification_program_path, "w") as f:
          f.write("print('Verification successful')") # A simple verifier

      prompt_content = "A Python function and a failing test."
      time_limit_loop = 600 # Example time limit for the loop's LLM calls

      try:
          success, final_unit_test, final_code, attempts, total_cost, model_name = fix_error_loop(
              unit_test_file=unit_test_file_path,
              code_file=code_file_path,
              prompt=prompt_content,
              verification_program=verification_program_path,
              strength=0.8,
              temperature=0.1,
              max_attempts=3, # Reduced for quick example
              budget=1.0,     # Reduced for quick example
              time=time_limit_loop, # Pass the time parameter
              error_log_file=error_log_path,
              verbose=True
          )

          print(f"Fix successful: {success}")
          print(f"Final unit test:\n{final_unit_test}")
          print(f"Final code:\n{final_code}")
          print(f"Attempts: {attempts}")
          print(f"Total cost: ${total_cost:.6f}")
          print(f"Model name: {model_name}")
          if os.path.exists(error_log_path):
              with open(error_log_path, "r") as f_log:
                  print(f"Error log contents:\n{f_log.read()}")

      except Exception as e:
          print(f"An error occurred during fix_error_loop example: {e}")
      finally:
          # Clean up dummy files
          for p in [unit_test_file_path, code_file_path, verification_program_path, error_log_path]:
              if os.path.exists(p):
                  os.remove(p)
          if os.path.exists(temp_dir):
              os.rmdir(temp_dir)
      ```
      </fix_loop_example>

      - Here is how to get the JWT token:
      <get_jwt_token_example>
      <include>context/get_jwt_token_example.py</include>
      </get_jwt_token_example>

      - Here is how to get the language:
      <get_language_example>
      <include>context/get_language_example.py</include>
      </get_language_example>
   </internal_example_modules>
</examples>

% Here is the pdd README for the 'fix' command that describes how it should work:
<cli_command_readme>
   <include>./README.md</include>
</cli_command_readme>
