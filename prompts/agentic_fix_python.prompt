You are an expert Python developer responsible for implementing the `agentic_fix.py` module. This module serves as the high-level orchestration layer for "agentic fallback" within a Prompt-Driven Development (PDD) toolchain. Its primary responsibility is to coordinate between LLM agents, local file systems, and verification commands to automatically repair code that failed standard automated fix attempts.

### Requirements
1. **Agent Orchestration**: Utilize `run_agentic_task` to invoke LLM agents in explore mode. Support multiple providers (Anthropic, Google, OpenAI) by detecting environment variables and available CLI tools. The agent directly modifies files on disk.
2. **Change Detection via Mtimes**:
    - Snapshot file modification times before and after agent execution.
    - Compare snapshots to detect all changed, new, and deleted files.
    - This approach is reliable regardless of agent output format.
3. **Verification Logic**:
    - Support a "preflight" check: if the error log is empty or contains useless content (like empty XML tags), run the tests locally first to capture actual failure output for the agent.
    - Provide a standard verification gate that uses `verify_cmd`, language-specific run commands, or a Python fallback.
    - For non-Python languages, trust the agent's own verification result.
4. **Logging & UI**: Use `rich.console` for formatted output. Support "quiet", "normal", and "verbose" log levels via environment variables (`PDD_AGENTIC_LOGLEVEL`). Show unified diffs of primary files in verbose mode.
5. **Resilience**: Handle timeouts for agent calls and verification steps. Ensure instruction files are cleaned up after execution.

### Dependencies
<get_language>
    <include>context/get_language_example.py</include>
</get_language>
<get_run_command>
    <include>context/get_run_command_example.py</include>
</get_run_command>
<llm_invoke>
    <include>context/llm_invoke_example.py</include>
</llm_invoke>
<load_prompt_template>
    <include>context/load_prompt_template_example.py</include>
</load_prompt_template>
<agentic_common>
    <include>context/agentic_common_example.py</include>
</agentic_common>
<agentic_langtest>
    <include>context/agentic_langtest_example.py</include>
</agentic_langtest>

### Instructions
1. **Entry Point**: Implement `run_agentic_fix(prompt_file, code_file, unit_test_file, error_log_file, ...)` as the main function.
2. **Path Resolution**: Resolve all input paths relative to the provided `cwd`. Use `Path.resolve()` to handle absolute vs. relative pathing consistently.
3. **Prompt Construction**: Load the `agentic_fix_primary_LLM` template (Python) or `agentic_fix_nonpython_LLM` template (other languages). Populate it with the absolute paths of the code and test files, the original prompt content, and the error log.
4. **Change Detection**:
    - Snapshot mtimes of all files under the project root before agent execution.
    - After agent completes, snapshot again and diff to identify all changes.
    - The agent edits files directly in explore mode â€” no output parsing needed.
5. **Verification Flow**:
    - For Python: run the test suite locally via `_verify_and_log` to confirm the fix works.
    - For non-Python: trust the agent's own result (it runs tests internally).
6. **Error Handling**: Wrap the orchestration in a try-except block to catch `FileNotFoundError` (missing CLIs) and general exceptions, returning a structured `(success, message, cost, model, changed_files)` tuple.

### Deliverables
A single Python file `agentic_fix.py` containing:
- The `run_agentic_fix` public function.
- Helper functions for mtime snapshots (`_snapshot_mtimes`, `_detect_mtime_changes`) and verification (`_verify_and_log`).
- Integration with `rich` for console logging.
