% Here is an example prompt generate as reference:
<example>
   <example_prompt><include>context/generate/6/conflicts_main_python.prompt</include></example_prompt>
   <example_code><include>context/generate/6/conflicts_main.py</include></example_code>
</example>

% You are an expert Python engineer. Your goal is to write the `change_main` function that will be part of the `pdd` command-line program. This function will handle the core logic for the `change` command.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
    - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
    - `change_prompt_file` (`str`): Path to the change prompt file.
    - `input_code` (`str`): Path to the input code file or directory (when used with the '--csv' option).
    - `input_prompt_file` (`Optional[str]`): Path to the input prompt file. Optional and not used when '--csv' is specified.
    - `output` (`Optional[str]`): Path to save the modified prompt file. If not specified, this will be generated based on the input files.
    - `csv` (`bool`): Flag indicating whether to use CSV mode for batch changes.

    Outputs:
    - Returns a tuple containing (`str`, `float`, `str`):
      - `str`: The modified prompt or a message indicating multiple prompts were updated.
      - `float`: The total cost of the operation (may be zero if not applicable).
      - `str`: The name of the model used.

<examples>
   % Here is how to use the Python Click library within a function:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Examples of using internal modules:
   <internal_example_modules>
      - Using the `get_extension` function:
      <get_extension_example>
      <include>context/get_extension_example.py</include>
      </get_extension_example>

      - Using the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Using the `change` function (`change_func`):
      <change_example>
      <include>context/change_example.py</include>
      </change_example>

      - Using the `process_csv_change` function:
      <process_csv_change_example>
      <include>context/process_csv_change_example.py</include>
      </process_csv_change_example>
   </internal_example_modules>
</examples>

% The function should perform the following steps:
   1. **Parse Arguments and Options**:
      - Check if the `csv` flag is set.
      - Validate mandatory arguments: `change_prompt_file` and `input_code` are always required.
      - When `csv` is False, validate that `input_prompt_file` is provided.
      - Provide informative messages if required arguments are missing.

   2. **Construct File Paths**:
      - Use `construct_paths` to load input files and establish output file paths.
      - When `csv` is True, `input_code` should be treated as a directory path and not included in the `input_file_paths` dictionary.
      - Respect `--force` and `--quiet` options from the CLI context.

   3. **Perform Prompt Modification**:
      - If `csv` is True:
        - Verify that `input_code` is a directory.
        - Call `process_csv_change` to handle batch changes specified in the change prompt file (which should be a CSV in this case).
      - Else:
        - Load `input_code_content` and `input_prompt_content` from the `input_strings` dictionary.
        - Call `change_func` to modify the input prompt based on the change prompt and code.

   4. **Save Results**:
      - Write the modified prompt(s) to the output location. For batch changes, this will involve updating multiple files.
      - Use the `output_file_paths` dictionary to determine the output path when not explicitly provided.

   5. **Provide User Feedback**:
      - Use `rprint` to display messages about the operation's success or failure.
      - Respect verbosity settings from the CLI context.

   6. **Error Handling**:
      - Implement try-except blocks to catch exceptions.
      - Use `ctx.exit(1)` to exit gracefully on fatal errors.

% Ensure adherence to the existing codebase's style, including type annotations, docstrings, and exception handling. Avoid name conflicts by importing modules with aliases where necessary (e.g., `from .change import change as change_func`).

% Important: Make sure to handle the `input_code` parameter correctly in both CSV and non-CSV modes. In CSV mode, it should be a directory path, while in non-CSV mode, it should be a file path.