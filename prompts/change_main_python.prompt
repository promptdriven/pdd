% Here is an example prompt generate as reference:
<example>
   <example_prompt><include>context/generate/6/conflicts_main_python.prompt</include></example_prompt>
   <example_code><include>context/generate/6/conflicts_main.py</include></example_code>
</example>

% You are an expert Python engineer. Your goal is to write the `change_main` function that will be part of the `pdd` command-line program. This function will handle the core logic for the `change` command.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
    - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
    - `change_prompt_file` (`str`): Path to the change prompt file.
    - `input_code` (`str`): Path to the input code file or directory (when used with the '--csv' option).
    - `input_prompt_file` (`Optional[str]`): Path to the input prompt file. Optional and not used when '--csv' is specified.
    - `output` (`Optional[str]`): Path to save the modified prompt file. If not specified, this will be generated based on the input files.
    - `use_csv` (`bool`): Flag indicating whether to use CSV mode for batch changes.

    Outputs:
    - Returns a tuple containing (`str`, `float`, `str`):
      - `str`: The modified prompt, a message indicating multiple prompts were updated, or an error message.
      - `float`: The total cost of the operation (may be zero if not applicable or on error).
      - `str`: The name of the model used (may be empty on error).

<examples>
   % Here is how to use the Python Click library within a function:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Examples of using internal modules:
   <internal_example_modules>
      - Using the `get_extension` function:
      <get_extension_example>
      <include>context/get_extension_example.py</include>
      </get_extension_example>

      - Using the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Using the `change` function (`change_func`):
      <change_example>
      <include>context/change_example.py</include>
      </change_example>

      - Using the `process_csv_change` function:
      <process_csv_change_example>
      <include>context/process_csv_change_example.py</include>
      </process_csv_change_example>
   </internal_example_modules>
</examples>

% The function should perform the following steps:
   1. **Set up logging**:
      - Import the logging module and set up a logger for the function.
      - Set the logging level to DEBUG for detailed logging.

   2. **Parse Arguments and Options**:
      - Check if the `use_csv` flag is set.
      - Validate mandatory arguments: `change_prompt_file` and `input_code` are always required.
      - When `use_csv` is False, validate that `input_prompt_file` is provided.
      - Provide informative messages if required arguments are missing.

   3. **Construct File Paths**:
      - Use `construct_paths` to load input files and establish output file paths.
      - When `use_csv` is True, `input_code` should be treated as a directory path and not included in the `input_file_paths` dictionary.
      - Respect `--force` and `--quiet` options from the CLI context.

   4. **Perform Prompt Modification**:
      - If `use_csv` is True:
        - Verify that `input_code` is a directory.
        - Validate the CSV file format to ensure it contains 'prompt_name' and 'change_instructions' columns.
        - Call `process_csv_change` to handle batch changes specified in the change prompt file (which should be a CSV in this case).
        - Ensure that `process_csv_change` returns a tuple with four elements: (success, modified_prompts, total_cost, model_name).
        - Use the `change_prompt_file` directly as the CSV file path, not its content.
      - Else:
        - Load `input_code_content` and `input_prompt_content` from the `input_strings` dictionary.
        - Call `change_func` to modify the input prompt based on the change prompt and code.

   5. **Save Results**:
      - For CSV mode:
        - If `output` is not specified, save individual files for each modified prompt.
        - If `output` is specified, save results as a CSV file.
      - For non-CSV mode:
        - Write the modified prompt to the output location.
      - Use the `output_file_paths` dictionary to determine the output path when not explicitly provided.

   6. **Provide User Feedback**:
      - Use `rprint` to display messages about the operation's success or failure.
      - Respect verbosity settings from the CLI context.
      - In CSV mode, provide information about individual files saved or the CSV output file.

   7. **Error Handling and Logging**:
      - Implement try-except blocks to catch exceptions at various stages.
      - Log detailed information about the execution flow and any errors encountered.
      - Return appropriate error messages, costs, and model names in case of failures.

% Ensure adherence to the existing codebase's style, including type annotations, docstrings, and exception handling. Use logging extensively for debugging and tracing the execution flow. Handle all potential error scenarios and provide informative error messages.

% Important: Make sure to handle the `input_code` parameter correctly in both CSV and non-CSV modes. In CSV mode, it should be a directory path, while in non-CSV mode, it should be a file path.

% Note: In the CSV mode, ensure that the `process_csv_change` function is called with the correct parameters, including using the `change_prompt_file` as the CSV file path directly, not its content. Also, handle the returned tuple correctly, which should now include a success flag.

% Use `use_csv` instead of `csv` for the boolean flag to avoid conflicts with the imported csv module.

% Implement robust error handling and logging throughout the function to facilitate debugging and provide clear feedback to users.