# sync_main_python.prompt

% You are an expert Python engineer. Your goal is to write a Python function, 'sync_main', that will be the CLI wrapper for the sync command. This function will handle the interface logic (e.g. grabbing environment variables, parameter validation, path construction) and then call the sync_orchestration function to perform the actual sync workflow.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object containing CLI options and parameters.
            Context parameters used:
            - strength (float): Model strength parameter, defaults to DEFAULT_STRENGTH
            - temperature (float): Model temperature parameter, defaults to 0.0
            - time (float): Model time parameter, defaults to DEFAULT_TIME
            - force (bool): Whether to force overwrite existing files
            - quiet (bool): Whether to suppress output messages
            - verbose (bool): Whether to enable verbose output for debugging purposes
            - output_cost (Optional[str]): Path to CSV file for cost tracking
            - review_examples (bool): Whether to review few-shot examples
            - local (bool): Whether to run commands locally instead of in cloud
            - log (bool): If True, display sync logs instead of running the sync.
        - `basename` (str): The base name for the prompt file (e.g., "factorial_calculator" for "factorial_calculator_python.prompt")
        - `max_attempts` (int): Maximum number of fix attempts in any iterative loop (default is 3)
        - `budget` (float): Maximum total cost allowed for the entire sync process (default is $10.0)
        - `skip_verify` (bool): Skip the functional verification step
        - `skip_tests` (bool): Skip unit test generation and fixing
        - `target_coverage` (float): Desired code coverage percentage (default is 90.0)

    Outputs:
        - Returns a tuple containing:
            - `Dict[str, Any]`: Comprehensive results dictionary from sync_orchestration
            - `float`: Total cost of the sync operation
            - `str`: Primary model name used during sync

% Important Implementation Notes:

1. **Parameter Retrieval**:
    - Retrieve `strength = ctx.obj.get('strength', DEFAULT_STRENGTH)`.
    - Retrieve `temperature = ctx.obj.get('temperature', 0.0)`.
    - Retrieve `time = ctx.obj.get('time', DEFAULT_TIME)`. (DEFAULT_TIME is imported from the package root)
    - Retrieve `verbose = ctx.obj.get('verbose', False)`.
    - Retrieve `force = ctx.obj.get('force', False)`.
    - Retrieve `quiet = ctx.obj.get('quiet', False)`.
    - Retrieve `output_cost = ctx.obj.get('output_cost', None)`.
    - Retrieve `review_examples = ctx.obj.get('review_examples', False)`.
    - Retrieve `local = ctx.obj.get('local', False)`.
    - Retrieve `context = ctx.obj.get('context', None)`.

2. **Log Mode**:
    - If `log` is True, the function should display the sync logs for the given basename and then exit.
    - It should iterate through each detected language, print a header, and call `sync_orchestration` with `log=True`.
    - No other processing, such as budgeting or result aggregation, should occur in this mode.

3. **Configuration and Path Handling**:
    - The `construct_paths` function handles `.pddrc` configuration files and context-aware settings
    - Pass `context_override=context` parameter to `construct_paths` when `--context` CLI option is used
    - `construct_paths` automatically handles:
        * Loading `.pddrc` configuration with upward directory search
        * Context detection based on current working directory paths  
        * Configuration hierarchy: CLI options > .pddrc context > environment variables > defaults
        * Path resolution for generate_output_path, test_output_path, example_output_path
        * Extracting context-specific settings like default_language, target_coverage, strength, temperature, budget, max_attempts
    - After calling `construct_paths`, extract resolved configuration settings and override CLI parameters if context provides them
    - Apply configuration hierarchy: prefer CLI-provided values, then context values, then original defaults

4. **Language Detection and Filtering**:
    - Scan for existing prompt files matching the pattern `{basename}_{language}.prompt` in the prompts directory
    - Filter to include only development languages (python, javascript, typescript, java, cpp, etc.)
    - Exclude runtime languages (LLM) as they cannot form valid development units:
        * Files ending in `_llm.prompt` are used for internal processing only
        * They don't have associated code, examples, or tests required for sync workflows
        * Including them in sync would always fail since they cannot be executed or tested
    - Sort detected development languages alphabetically
    - If no valid development prompt files found, raise `click.UsageError` with helpful message
    - For each found development prompt file, run the complete sync workflow (calling sync_orchestration)
    - Each sync_orchestration call will use construct_paths normally with that specific prompt file

5. **File Path Validation**:
    - Validate that required prompt files exist for the given basename
    - Ensure output directories are accessible  
    - `construct_paths` handles directory creation and path resolution automatically

6. **Error Handling Requirements**:
    - Validate basename parameter:
        * Raise `click.UsageError` if basename is empty or contains invalid characters
        * Check that at least one prompt file exists for the basename
    - Handle budget and attempts validation:
        * Ensure budget > 0 and max_attempts > 0
        * Warn if budget seems too low for typical sync operations
    - Handle configuration errors:
        * Catch `.pddrc` YAML syntax errors and provide helpful messages
        * Validate unknown context names when using `--context`
        * Handle missing or inaccessible configuration files gracefully
    - Use `try/except` blocks for file operations
    - Provide formatted error messages using `rich.print`
    - Exit with appropriate error codes on critical failures

7. **User Feedback**:
    - Use `rich.print` for formatted output (unless `quiet` is True)
    - Show sync progress summary before starting, including:
        * Detected context (if using .pddrc)
        * Languages being processed
        * Configuration settings being applied
    - Display final results including:
        * Total operations completed
        * Total cost and time elapsed
        * Files created/updated
        * Any errors or warnings
    - Provide helpful suggestions for common issues

8. **Integration with sync_orchestration**:
    - Import and call `sync_orchestration` function from the sync orchestration module
    - Pass all parameters properly mapped to sync_orchestration's interface, ensuring directory parameters match the expected names (prompts_dir, code_dir, examples_dir, tests_dir)
    - Handle return values and format them for CLI output

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to get the language:
      <get_language_example>
      <include>context/get_language_example.py</include>
      </get_language_example>

      - Here is how to use the `sync_orchestration` function:
      <sync_orchestration_example>
        <include>context/sync_orchestration_example.py</include>
      </sync_orchestration_example>

      - Here is an example of language detection for sync using existing PDD functions, excluding runtime languages:
      <language_detection_example>
      ```python
      import glob
      from pathlib import Path
      from pdd.construct_paths import _is_known_language

      def detect_languages_for_basename(basename: str, prompts_dir: str = "prompts") -> list:
          """Detect development languages that have prompt files for a given basename, excluding runtime languages"""
          prompts_path = Path(prompts_dir)
          pattern = f"{basename}_*.prompt"
          
          prompt_files = list(prompts_path.glob(pattern))
          development_languages = []
          
          for prompt_file in prompt_files:
              # Extract language from filename: basename_language.prompt
              stem = prompt_file.stem  # removes .prompt
              if '_' in stem:
                  potential_language = stem.split('_', 1)[1]  # Get everything after first underscore
                  # Validate using existing PDD function
                  if _is_known_language(potential_language):
                      # Exclude runtime languages (LLM) as they cannot form valid development units
                      if potential_language.lower() != 'llm':
                          development_languages.append(potential_language)
          
          # Return only development languages, sorted alphabetically
          return sorted(development_languages)
      ```
      </language_detection_example>
   </internal_example_modules>
</examples>

% Here is the PDD README for the 'sync' command that describes how it should work:
<cli_command_readme>
   <include>README.md</include>
</cli_command_readme>

% Implementation Requirements:

1. **Main Function Structure**:
   - Follow the same pattern as other PDD main functions (like fix_main)
   - Handle all CLI interface logic in sync_main
   - Delegate actual sync workflow to sync_orchestration
   - Return appropriate tuple for CLI result callback

2. **Multiple Language Support**:
   - If multiple language prompt files exist for the same basename, process all of them
   - Run sync_orchestration separately for each detected language
   - Combine results and costs from all language syncs

3. **Path Management**:
   - Use `construct_paths` function for all file path construction and configuration resolution
   - `construct_paths` handles environment variables, .pddrc configuration, and directory creation
   - Focus on parameter validation and configuration hierarchy rather than path manipulation

4. **Progress Reporting**:
   - Show which language(s) are being processed
   - Display progress for each major step
   - Provide clear success/failure indicators

5. **State Management**:
   - Let sync_orchestration handle git integration and state tracking
   - Don't duplicate state management logic in sync_main
   - Pass through all necessary parameters for state handling

The sync_main function should act as a clean interface layer that handles CLI parameter extraction and validation while delegating path construction to `construct_paths` and the actual sync workflow intelligence to sync_orchestration. Cost tracking is automatically handled by the `@track_cost` decorator at the CLI level.