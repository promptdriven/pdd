# sync_main_python.prompt

% You are an expert Python engineer. Your goal is to write a Python function, 'sync_main', that will be the CLI wrapper for the sync command. This function handles interface logic (environment variables, parameter validation, path construction) and calls sync_orchestration to perform the actual sync workflow.

<include>context/python_preamble.prompt</include>

% Standard ctx.obj parameters (see included file for details):
<include>context/ctx_obj_params.prompt</include>

% Inputs and Outputs:
    Inputs:
        - `ctx` (`click.Context`): Click context with CLI options from ctx.obj:
            - output_cost (Optional[str]): Path to CSV file for cost tracking
            - review_examples (bool): Whether to review few-shot examples
            - local (bool): Whether to run locally instead of cloud
        - `basename` (str): Base name for prompt file (e.g., "factorial_calculator" or "core/cloud" for subdirectories)
        - `max_attempts` (Optional[int]): Maximum fix attempts. None = use .pddrc or default (3). 0 = skip LLM loop, go straight to agentic mode.
        - `budget` (Optional[float]): Maximum cost allowed. None = use .pddrc or default (20.0)
        - `skip_verify` (bool): Skip functional verification
        - `skip_tests` (bool): Skip unit test generation
        - `target_coverage` (Optional[float]): Code coverage percentage. None = use .pddrc or default (90.0)
        - `dry_run` (bool): Analyze sync state without executing operations

    Outputs:
        - Tuple of (Dict[str, Any] results, float total_cost, str model_name)

% Key Implementation Details:

1. **Parameter Resolution**:
    - Use `ctx.obj.get(key, default)` pattern for ctx.obj parameters
    - Import DEFAULT_STRENGTH, DEFAULT_TIME from package root
    - Name context variable `context_override`, time variable `time_param` to avoid shadowing builtins
    - Configuration hierarchy: CLI value (if not None) > .pddrc value > hardcoded default

2. **Prompt Discovery** (two-stage):
    - **Template-based discovery (primary)**: Search contexts in .pddrc for `outputs.prompt.path` templates. Expand template with basename and common languages until a prompt file is found. Use `_find_pddrc_file`, `_load_pddrc_config`, and `expand_template` from template_expander.
    - **Directory scanning (fallback)**: If template discovery fails, call `construct_paths` in discovery mode and scan prompts_dir for `{basename}_{language}.prompt` files.
    - When template discovery succeeds, set `context_override` to the discovered context name (if not already set by user).

3. **Dry-Run Mode**:
    - Display sync analysis for basename, then exit
    - Iterate through each detected language, print header, call sync_orchestration with `dry_run=True`
    - Pass directory parameters, verbose, quiet, context_override to sync_orchestration
    - Use `force=True` in construct_paths to avoid interactive prompts
    - Return `({}, 0.0, "")` after processing all languages

4. **Path and Configuration**:
    - `construct_paths` handles .pddrc configuration, context detection, and path resolution
    - Returns 4-tuple: `(resolved_config, _, _, resolved_language)` - second/third elements unused
    - Extract settings from resolved_config: strength, temperature, target_coverage, max_attempts, budget
    - Update ctx.obj with resolved strength/temperature for sub-commands

5. **Language Detection**:
    - If context was discovered via template, use template-based detection: expand template for each known language and check file existence
    - Otherwise, scan for prompt files matching `{basename}_{language}.prompt` in prompts directory
    - Support subdirectory basenames (e.g., "core/cloud" searches prompts/core/ for cloud_*.prompt)
    - Exclude runtime languages (LLM) - they cannot form valid development units
    - Python prioritized first, then remaining languages sorted alphabetically
    - Raise `click.UsageError` if no valid development prompt files found

6. **Basename Validation**:
    - Regex: `^[a-zA-Z0-9_-]+(/[a-zA-Z0-9_-]+)*$` (alphanumeric, underscore, hyphen, forward slash for subdirs)
    - Reject empty, path traversal (..), absolute paths, trailing slashes, double slashes
    - Raise `click.UsageError` for invalid basenames

7. **Budget/Attempts Validation**:
    - Budget must be > 0, max_attempts must be >= 0 (raise `click.BadParameter` if not)
    - Warn if budget < 1.0: `Warning: Budget of $X.XX is low`
    - max_attempts=0 is valid (skips LLM loop, goes straight to agentic mode)

8. **Multi-Language Processing**:
    - Process each detected language separately via sync_orchestration
    - Track remaining_budget across languages (reduce after each language's cost)
    - Skip subsequent languages if budget exhausted
    - Aggregate results and costs from all language syncs

9. **User Feedback** (unless quiet=True):
    - Show sync progress summary before starting (detected context, languages, settings)
    - Display final results table (language, status, cost, details)
    - Total time elapsed, total cost, overall status

<examples>
   <sync_main_example>
   <include>context/sync_main_example.py</include>
   </sync_main_example>

   <construct_paths_example>
   <include>context/construct_paths_example.py</include>
   </construct_paths_example>

   <sync_orchestration_example>
   <include>context/sync_orchestration_example.py</include>
   </sync_orchestration_example>
</examples>

% CLI command documentation:
<cli_command_readme>
   <include>README.md</include>
</cli_command_readme>

% Implementation Pattern:
- Follow same pattern as other PDD main functions (like fix_main)
- Handle CLI interface logic in sync_main, delegate workflow to sync_orchestration
- Use `construct_paths` for all path construction and configuration resolution
- Let sync_orchestration handle git integration and state tracking
- Cost tracking handled by `@track_cost` decorator at CLI level
