
% Goal: Write a function `fix_code_loop` that attempts to fix errors in a code module through multiple LLM-driven iterations, with verbose mode, hybrid cloud support, and agentic fallback for non-Python or stuck scenarios.

<include>context/python_preamble.prompt</include>

<module_dependencies>
  <pdd.agentic_crash><include>context/agentic_crash_example.py</include></pdd.agentic_crash>
  <pdd.agentic_langtest><include>context/agentic_langtest_example.py</include></pdd.agentic_langtest>
  <pdd.get_language><include>context/get_language_example.py</include></pdd.get_language>
  <pdd.fix_code_module_errors><include>context/fix_code_module_errors_example.py</include></pdd.fix_code_module_errors>
</module_dependencies>

% Signature
  fix_code_loop(
    code_file: str, prompt: str, verification_program: str,
    strength: float, temperature: float, max_attempts: int, budget: float,
    error_log_file: str, verbose: bool = False, time: float = DEFAULT_TIME,
    prompt_file: str = "", agentic_fallback: bool = True,
    use_cloud: bool = False
  ) -> Tuple[bool, str, str, int, float, Optional[str]]
  # Returns: (success, final_program, final_code, total_attempts, total_cost, model_name)
  # On failure: success=False, final_program="", final_code="" (even if originals restored)
  # Hybrid Cloud: When use_cloud=True, LLM fix calls go to cloud crashCode endpoint while local program execution stays local.

% Helpers
  - `_normalize_agentic_result(result)`: Normalize 2/3/4/5-tuple from run_agentic_crash to 5-tuple.
  - `_safe_run_agentic_crash(*, prompt_file, code_file, program_file, crash_log_file, cwd=None)`: Wrapper that returns failure if prompt_file empty. Maps verification_program → program_file, error_log_file → crash_log_file. Pass `cwd=Path(prompt_file).parent` when calling.
  - `run_process_with_output(cmd_args, timeout=300)`: Subprocess with threaded byte-by-byte streaming capture. Returns (returncode, stdout, stderr).
  - `ProcessResult`: Simple class holding returncode, stdout, stderr.
  - `cloud_crash_fix(program, prompt, code, errors, strength, temperature, time, verbose, program_path, code_path, language)`: Call cloud crashCode endpoint for LLM crash fix. Returns (update_program, update_code, fixed_program, fixed_code, analysis, cost, model_name). Falls back to local on cloud failure.

% Process
  0. Validate files: code_file missing → FileNotFoundError; verification_program missing → return failure. Non-Python: run default_verify_cmd_for, trigger agentic fallback on failure or return success.

  1. Remove error_log_file if exists. Create backups: `{stem}_original_backup{suffix}`.

  2. Init: attempts=0, total_cost=0.0, success=False, model_name=None, history_log="<history>\n".

  3. Loop while attempts < max_attempts and total_cost <= budget:
     - Run verification (300s timeout), append <verification> with <status>/<output>/<error> CDATA.
     - Success (rc=0): break. Failure: add <current_error>, check limits.
     - Create per-attempt backups: `{base}_{N}{ext}`.
     - Call fix_code_module_errors, append <fixing> with <llm_analysis>/<decision>/<cost>/<model>.
     - Write history to error_log_file. Accumulate cost.
     - Stop if budget exceeded or no changes suggested.
     - Apply fixes, then increment attempts.

  4. On failure: restore original backups. Always cleanup backups. Write final history.

  5. Success: read final contents. Failure: return empty strings.

  6. If failure + agentic_fallback: ensure error_log_file exists, call _safe_run_agentic_crash with `cwd=Path(prompt_file).parent`, re-read on success.

  7. Return (success, final_program, final_code, attempts, total_cost, model_name).

% XML Log Format
  ```xml
  <history>
    <attempt number="1">
      <verification><status>...</status><output><![CDATA[...]]></output><error><![CDATA[...]]></error></verification>
      <current_error><![CDATA[...]]></current_error>
      <fixing><llm_analysis><![CDATA[...]]></llm_analysis><decision>update_program: true\nupdate_code: false</decision><cost>0.05</cost><model>...</model></fixing>
    </attempt>
  </history>
  ```

% Keep `if __name__ == "__main__":` demo harness with dummy files and monkeypatched fix_code_module_errors.
