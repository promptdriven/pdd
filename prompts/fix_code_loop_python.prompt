
% Goal: Write a function `fix_code_loop` that attempts to fix errors in a code module through multiple LLM-driven iterations, with verbose mode and agentic fallback for non-Python or stuck scenarios.

<include>context/python_preamble.prompt</include>

% Signature
  fix_code_loop(
    code_file: str, prompt: str, verification_program: str,
    strength: float, temperature: float, max_attempts: int, budget: float,
    error_log_file: str, verbose: bool = False, time: float = DEFAULT_TIME,
    prompt_file: str = "", agentic_fallback: bool = True
  ) -> Tuple[bool, str, str, int, float, Optional[str]]
  # Returns: (success, final_program, final_code, total_attempts, total_cost, model_name)
  # On failure: success=False, final_program="", final_code="" (even if originals restored)

% Dependencies (with ImportError fallback stubs)
  - `agentic_fix.run_agentic_fix(prompt_file, code_file, unit_test_file, error_log_file)` → (success, msg, cost, model, changed_files)
  - `get_language.get_language(ext)` → language string
  - `agentic_langtest.default_verify_cmd_for(lang, verification_program)` → shell command
  - `fix_code_module_errors.fix_code_module_errors(program, prompt, code, errors, strength, temperature, time, verbose)` → (update_program, update_code, fixed_program, fixed_code, analysis, cost, model_name)

% Helpers
  - `_normalize_agentic_result(result)`: Normalize 2/3/4/5-tuple from run_agentic_fix to 5-tuple.
  - `_safe_run_agentic_fix(*, prompt_file, code_file, unit_test_file, error_log_file)`: Wrapper that returns failure if prompt_file empty.
  - `run_process_with_output(cmd_args, timeout=300)`: Subprocess with threaded byte-by-byte streaming capture. Returns (returncode, stdout, stderr).
  - `ProcessResult`: Simple class holding returncode, stdout, stderr.

% Process
  0. Validate files: code_file missing → FileNotFoundError; verification_program missing → return failure. Non-Python: run default_verify_cmd_for, trigger agentic fallback on failure or return success.

  1. Remove error_log_file if exists. Create backups: `{stem}_original_backup{suffix}`.

  2. Init: attempts=0, total_cost=0.0, success=False, model_name=None, history_log="<history>\n".

  3. Loop while attempts < max_attempts and total_cost <= budget:
     - Run verification (300s timeout), append <verification> with <status>/<output>/<error> CDATA.
     - Success (rc=0): break. Failure: add <current_error>, check limits.
     - Create per-attempt backups: `{base}_{N}{ext}`.
     - Call fix_code_module_errors, append <fixing> with <llm_analysis>/<decision>/<cost>/<model>.
     - Write history to error_log_file. Accumulate cost.
     - Stop if budget exceeded or no changes suggested.
     - Apply fixes, then increment attempts.

  4. On failure: restore original backups. Always cleanup backups. Write final history.

  5. Success: read final contents. Failure: return empty strings.

  6. If failure + agentic_fallback: ensure error_log_file exists, call _safe_run_agentic_fix, re-read on success.

  7. Return (success, final_program, final_code, attempts, total_cost, model_name).

% XML Log Format
  ```xml
  <history>
    <attempt number="1">
      <verification><status>...</status><output><![CDATA[...]]></output><error><![CDATA[...]]></error></verification>
      <current_error><![CDATA[...]]></current_error>
      <fixing><llm_analysis><![CDATA[...]]></llm_analysis><decision>update_program: true\nupdate_code: false</decision><cost>0.05</cost><model>...</model></fixing>
    </attempt>
  </history>
  ```

% Keep `if __name__ == "__main__":` demo harness with dummy files and monkeypatched fix_code_module_errors.
