% You are an expert Python Software Engineer. Your goal is to write a Python function, "fix_code_loop", that will attempt to fix errors in a code module through multiple iterations, with an added verbose mode for detailed logging.

<include>context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
  Inputs:
    - `code_file`: A string containing the path to the code file being tested.
    - `prompt`: A string containing the prompt that generated the code under test.
    - `verification_program`: A string containing the path to a Python program that verifies if the code runs correctly.
    - `strength`: A float between or equal to 0 and 1 that represents the strength of the LLM model to use.
    - `temperature`: A float between or equal to 0 and 1 that represents the temperature parameter for the LLM model.
    - `max_attempts`: An integer representing the maximum number of fix attempts before giving up.
    - `budget`: A float representing the maximum cost allowed for the fixing process.
    - `error_log_file`: A string containing the path to the error log file (default: "error_code.log").
    - `verbose`: A boolean flag to enable detailed logging of the fixing process (default: False).
  Outputs:
    - `success`: A boolean indicating whether the errors were successfully fixed.
    - `final_program`: A string containing the contents of the final verification program file.
    - `final_code`: A string containing the contents of the final code file.
    - `total_attempts`: An integer representing the number of fix attempts made.
    - `total_cost`: A float representing the total cost of all fix attempts.
    - `model_name`: A string representing the name of the LLM model used.

% Here are examples of how to use internal modules:
<internal_example_modules>
  % Here is an example of the `fix_code_module_errors` function that will be used:
  <fix_code_module_errors_example>
  <include>context/fix_code_module_errors_example.py</include>
  </fix_code_module_errors_example>
</internal_example_modules>

% This function will do the following:
  Step 1. Remove the existing error log file specified by `error_log_file` if it exists.
  Step 2. Initialize variables:
    - Counter for the number of attempts.
    - Total cost accumulator.
    - Initialize history log for tracking attempts with structured XML format.
  Step 3. Enter a while loop that continues until `max_attempts` is reached or `budget` is exceeded:
    a. Print out to console and error log file the attempt iteration.
    b. Run the `verification_program` to test the `code_file`, capturing its output and errors.
    c. If the program runs without errors, break the loop.
    d. If the program fails:
       - Create a structured history log with specific XML tags:
         * Use <attempt number="X"> to start each attempt record
         * Within each attempt, include these sections:
           <verification>
             Status: Success/failure status with return code
             Output: [Standard output text]
             Error: [Error message text]
           </verification>
           
           <current_error>
             [Current error message to be fixed]
           </current_error>
           
           <fixing>
             <llm_analysis>
               [Analysis from the LLM in human-readable format]
             </llm_analysis>
             <decision>
               update_program: true/false
               update_code: true/false
             </decision>
           </fixing>
         * Use human-readable formatting within XML tags
         * Save this structured log incrementally to the error log file
         * Pass the complete history log to `fix_code_module_errors` using the `errors` parameter for context on previous attempts
       - Create backup copies of the verification program and code file
       - Read the contents of both files
       - Call `fix_code_module_errors` with the enriched history
       - Update files based on the fix results
       - Track total cost and check against budget
    e. Increment the attempt counter.
  Step 4. If the last run didn't work, copy back the `verification_program` and `code_file` from the original.
  Step 5. Return the success status, final verification program, final code contents, total number of attempts, total cost, and model name.