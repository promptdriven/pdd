% You are an expert Python engineer. Your goal is to write a Python function, 'preprocess_main', that will be the CLI wrapper for preprocessing prompts. This function will read a prompt file, preprocess its contents using the preprocess function (or XML-tagging flow), and handle the output location.

<include>./context/python_preamble.prompt</include>
<include>./context/ctx_obj_params.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object (see ctx_obj_params.prompt for available keys).
        - 'prompt_file' - A string containing the path to the prompt file to preprocess.
        - 'output' - An optional string containing the path where to save the preprocessed prompt. If None, uses default naming convention.
        - 'xml' - A boolean that is True if XML delimiters should be automatically inserted for better structure. Default is False.
        - 'recursive' - A boolean to recursively preprocess includes. Default is False.
        - 'double' - A boolean to enable double-curly-brace doubling. Default is False.
        - 'exclude' - An optional list of strings indicating keys to exclude from curly brace doubling.
        - 'pdd_tags' - A boolean. If True, inject PDD metadata tags (<pdd-reason>, <pdd-interface>, <pdd-dependency>) from architecture.json before preprocessing. Default is False.
    Outputs:
        - Returns a tuple containing (`str`, `float`, `str`):
            - `str`: The preprocessed prompt.
            - `float`: The total cost of the operation (primarily from `xml_tagger` if used).
            - `str`: The name of the model used (primarily by `xml_tagger` if used, "N/A" otherwise).

<examples>
   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `preprocess` function:
      <preprocess_example>
      <include>context/preprocess_example.py</include>
      </preprocess_example>

      - Here is an example of how to use the `xml_tagger` function.
        Note: The `xml_tagger` function accepts a `time: float` parameter (0.0â€“1.0) representing a time budget for the tagging operation, alongside `raw_prompt`, `strength`, `temperature`, and `verbose`. The signature is: `xml_tagger(raw_prompt: str, strength: float, temperature: float, verbose: bool, time: float = DEFAULT_TIME) -> Tuple[str, float, str]`. Internally, it may use a fixed `EXTRACTION_STRENGTH` for extraction.
      <xml_tagger_example>
      <include>context/xml_tagger_example.py</include>
      </xml_tagger_example>

      - Here is an example of how to use the `architecture_sync` module functions for PDD tags injection:
        - `get_architecture_entry_for_prompt(prompt_filename: str) -> Optional[Dict]`: Returns the architecture.json entry for a prompt, or None if not found.
        - `has_pdd_tags(content: str) -> bool`: Checks if prompt content already contains PDD metadata tags.
        - `generate_tags_from_architecture(arch_entry: Dict) -> str`: Generates XML tags string (<pdd-reason>, <pdd-interface>, <pdd-dependency>) from an architecture entry.
      <architecture_sync_usage>
      from .architecture_sync import (
          get_architecture_entry_for_prompt,
          generate_tags_from_architecture,
          has_pdd_tags,
      )

      # Get architecture entry for a prompt
      arch_entry = get_architecture_entry_for_prompt("my_module_python.prompt")
      if arch_entry and not has_pdd_tags(prompt_content):
          tags = generate_tags_from_architecture(arch_entry)
          prompt_content = tags + '\n\n' + prompt_content
      </architecture_sync_usage>
   </internal_example_modules>
</examples>

% Here is the README for the cli command that has details of how the 'preprocess' command and '--xml' sub command work.
% The 'preprocess_main' function should implement the following logic:
    1. Use `construct_paths` to determine input and output file paths:
        - Call `construct_paths` with `input_file_paths={"prompt_file": prompt_file}`, `command="preprocess"`, `command_options={"output": output}`, and pass through `force`/`quiet` from `ctx.obj`, plus `context_override=ctx.obj.get('context')` so a global `--context` is honored.
    2. Load the content of the `prompt_file` from `input_strings["prompt_file"]`.
    2b. If `pdd_tags` is True:
        a. Get the prompt filename from the path using `Path(prompt_file).name`.
        b. Look up the architecture entry using `get_architecture_entry_for_prompt(prompt_filename)`.
        c. If entry exists and the prompt does NOT already have PDD tags (check with `has_pdd_tags()`):
           - Generate tags using `generate_tags_from_architecture(arch_entry)`.
           - Prepend tags to prompt content: `prompt = tags + '\n\n' + prompt`.
           - Print success message if not quiet mode.
        d. If prompt already has PDD tags, print a warning and skip injection.
        e. If no architecture entry found, print a warning and skip injection.
    3. If `xml` is True:
        a. Retrieve global options from `ctx.obj`:
            - `strength = ctx.obj.get("strength", DEFAULT_STRENGTH)`
            - `temperature = ctx.obj.get("temperature", 0.0)`
            - `verbose = ctx.obj.get("verbose", False)`
            - `time = ctx.obj.get("time", DEFAULT_TIME)`
        b. Call `xml_tagger(prompt, strength, temperature, verbose, time=time)`.
        c. Use the result from `xml_tagger` (tagged prompt, cost, model name).
    4. If `xml` is False:
        a. Call `preprocess(prompt, recursive=recursive, double_curly_brackets=double, exclude_keys=exclude)`.
        b. Set `total_cost = 0.0` and `model_name = "N/A"`.
    5. Save the resulting preprocessed (or XML-tagged) prompt to `output_file_paths["output"]`.
    6. Print success messages and cost/model information if not in `quiet` mode.
    7. Handle exceptions gracefully and exit with a non-zero status code if an error occurs.
   <cli_command_readme>
   <include>./README.md</include>
   </cli_command_readme>
