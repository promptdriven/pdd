% You are an expert Python engineer. Your goal is to write a Python function, 'preprocess_main', that will be the CLI wrapper for preprocessing prompts. This function will read a prompt file, preprocess its contents using the preprocess function (or XML-tagging flow), and handle the output location.

<include>./context/python_preamble.prompt</include>

% Here are the inputs and outputs of the function:
    Inputs:
        - `ctx` (`click.Context`): The Click context object containing CLI options and parameters. This object will be used to access global options like `force`, `quiet`, `strength`, `temperature`, `verbose`, and `time`.
        - 'prompt_file' - A string containing the path to the prompt file to preprocess.
        - 'output' - An optional string containing the path where to save the preprocessed prompt. If None, uses default naming convention.
        - 'xml' - A boolean that is True if XML delimiters should be automatically inserted for better structure. Default is False.
        - 'recursive' - A boolean to recursively preprocess includes. Default is False.
        - 'double' - A boolean to enable double-curly-brace doubling. Default is False.
        - 'exclude' - An optional list of strings indicating keys to exclude from curly brace doubling.
    Outputs:
        - Returns a tuple containing (`str`, `float`, `str`):
            - `str`: The preprocessed prompt.
            - `float`: The total cost of the operation (primarily from `xml_tagger` if used).
            - `str`: The name of the model used (primarily by `xml_tagger` if used, "N/A" otherwise).

<examples>
   % Here is how to use the Python Click library to create a command line program:
   <click_example>
   <include>context/click_example.py</include>
   </click_example>

   % Here are examples of how to use internal modules:
   <internal_example_modules>
      - Here is an example of how to use the `construct_paths` function:
      <construct_paths_example>
      <include>context/construct_paths_example.py</include>
      </construct_paths_example>

      - Here is an example of how to use the `preprocess` function:
      <preprocess_example>
      <include>context/preprocess_example.py</include>
      </preprocess_example>

      - Here is an example of how to use the `xml_tagger` function.
        Note: The `xml_tagger` function accepts a `time: float` parameter (0.0â€“1.0) representing a time budget for the tagging operation, alongside `raw_prompt`, `strength`, `temperature`, and `verbose`. The signature is: `xml_tagger(raw_prompt: str, strength: float, temperature: float, verbose: bool, time: float = DEFAULT_TIME) -> Tuple[str, float, str]`. Internally, it may use a fixed `EXTRACTION_STRENGTH` for extraction.
      <xml_tagger_example>
      <include>context/xml_tagger_example.py</include>
      </xml_tagger_example>
   </internal_example_modules>
</examples>

% Here is the README for the cli command that has details of how the 'preprocess' command and '--xml' sub command work.
% The 'preprocess_main' function should implement the following logic:
    1. Use `construct_paths` to determine input and output file paths:
        - Call `construct_paths` with `input_file_paths={"prompt_file": prompt_file}`, `command="preprocess"`, `command_options={"output": output}`, and pass through `force`/`quiet` from `ctx.obj`.
    2. Load the content of the `prompt_file` from `input_strings["prompt_file"]`.
    3. If `xml` is True:
        a. Retrieve global options from `ctx.obj`:
            - `strength = ctx.obj.get("strength", DEFAULT_STRENGTH)`
            - `temperature = ctx.obj.get("temperature", 0.0)`
            - `verbose = ctx.obj.get("verbose", False)`
            - `time = ctx.obj.get("time", DEFAULT_TIME)`
        b. Call `xml_tagger(prompt, strength, temperature, verbose, time=time)`.
        c. Use the result from `xml_tagger` (tagged prompt, cost, model name).
    4. If `xml` is False:
        a. Call `preprocess(prompt, recursive=recursive, double_curly_brackets=double, exclude_keys=exclude)`.
        b. Set `total_cost = 0.0` and `model_name = "N/A"`.
    5. Save the resulting preprocessed (or XML-tagged) prompt to `output_file_paths["output"]`.
    6. Print success messages and cost/model information if not in `quiet` mode.
    7. Handle exceptions gracefully and exit with a non-zero status code if an error occurs.
   <cli_command_readme>
   <include>./README.md</include>
   </cli_command_readme>
