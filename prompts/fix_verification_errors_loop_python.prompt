% Write function "fix_verification_errors_loop" that iteratively fixes code errors by comparing program execution output against the original prompt's intent.

<include>context/python_preamble.prompt</include>

% Signature:
def fix_verification_errors_loop(
    program_file: str,           # Python program exercising code_file
    code_file: str,              # Code being verified/fixed
    prompt: str,                 # Prompt defining intended behavior
    prompt_file: str,            # Path to prompt file (for agentic fallback)
    verification_program: str,   # Secondary verification program (must exist)
    strength: float,             # [0,1] LLM model strength
    temperature: float,          # [0,1] LLM temperature
    max_attempts: int,           # Max fix attempts
    budget: float,               # Max cost allowed
    verification_log_file: str = "verification.log",
    output_code_path: Optional[str] = None,
    output_program_path: Optional[str] = None,
    verbose: bool = False,
    program_args: Optional[list[str]] = None,
    llm_time: float = DEFAULT_TIME,
    agentic_fallback: bool = True,
) -> Dict[str, Any]:  # Returns: success, final_program, final_code, total_attempts, total_cost, model_name, statistics

% Dependencies:
<fix_verification_errors_example>
    <include>context/fix_verification_errors_example.py</include>
</fix_verification_errors_example>

Also use: run_agentic_fix, get_language, default_verify_cmd_for

% Algorithm:
1. Non-Python targets (.py check): bypass loop, use get_language()/default_verify_cmd_for(), invoke run_agentic_fix
2. Validate inputs (files exist, params in range); return failure with empty statistics if invalid
3. Initial assessment: run program_file, call fix_verification_errors
   - Abort on error sentinel (explanation=None AND model_name=None)
   - Return success if verification_issues_count == 0; return failure if budget exceeded
4. Main loop (attempts < max_attempts, budget not exceeded):
   - Run program, backup files, call fix_verification_errors
   - If code changed: run verification_program; apply if passes, discard if fails
   - Track best iteration (lowest issues where verification passed)
   - Break on success (0 issues + verified) or no effective changes
5. Final: return success if any verification passed; else restore best/original state
6. Agentic fallback: if failed and agentic_fallback=True, invoke run_agentic_fix

% XML Logging (xml.sax.saxutils.escape):
<InitialState>, <Iteration attempt="N"> (with <SecondaryVerification passed="true/false">), <FinalActions>

% Deliverables:
Implement to pass all tests in tests/test_fix_verification_errors_loop.py. Include helpers for subprocess execution and log writing.
