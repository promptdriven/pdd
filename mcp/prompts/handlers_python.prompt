You are an expert Python Engineerand MCP architect for PDD MCP Server. Your goal is to write the complete code for generating the `pdd_mcp_server/tools/handlers.py` Python file. This will have handler functions for all of the PDD commands.

This `handlers.py` module is crucial as it contains the logic that gets executed when an MCP client invokes a tool corresponding to a PDD CLI command. It acts as the bridge between the MCP framework and the actual execution of `pdd` commands via the `runner.py` module.

**Core Task for `handlers.py`:**

The primary responsibility of `handlers.py` is to:
1.  Import necessary types and functions (`mcp.types`, `PddResult`, `run_pdd_command` from `.runner`).
2.  Define an `async` handler function for **each** PDD command exposed as an MCP tool (e.g., `handle_pdd_generate`, `handle_pdd_test`, `handle_pdd_fix`, etc.). The full list of commands to handle can be derived from the PDD CLI README and the MCP Server README tool table: `generate`, `example`, `test`, `preprocess`, `fix`, `split`, `change`, `update`, `detect`, `conflicts`, `crash`, `trace`, `bug`, `auto-deps`.

    Specifically, you must implement the following handler functions:
    *   `handle_pdd_generate`
    *   `handle_pdd_example`
    *   `handle_pdd_test`
    *   `handle_pdd_preprocess`
    *   `handle_pdd_fix`
    *   `handle_pdd_split`
    *   `handle_pdd_change`
    *   `handle_pdd_update`
    *   `handle_pdd_detect`
    *   `handle_pdd_conflicts`
    *   `handle_pdd_crash`
    *   `handle_pdd_trace`
    *   `handle_pdd_bug`
    *   `handle_pdd_auto_deps` (Note: the command `auto-deps` translates to `auto_deps` in the function name).

3.  Each handler function will accept a single argument: `arguments: dict`, which contains the validated parameters passed by the MCP client (matching the schema defined in `definitions.py`).
4.  Inside each handler, translate the `arguments` dictionary into a `list[str]` representing the command-line invocation for the *specific* `pdd` command (e.g., `['pdd', 'generate', '--output', arguments['output'], arguments['prompt_file']]`). This involves:
    *   Starting with the base command (e.g., `['pdd', 'generate']`).
    *   Appending required positional arguments based on the `arguments` dict.
    *   Checking for *optional* arguments in the `arguments` dict. If an optional argument key exists and its value is not `None`, append the corresponding command-line flag and its value (if applicable) to the list. For example, if `arguments.get('output')` is not `None`, append `['--output', arguments['output']]`.
    *   Handling boolean flags: If a boolean argument key exists and its value is `True`, append the corresponding flag (e.g., if `arguments.get('loop')` is `True`, append `'--loop'`).
    *   Carefully consider the order and format required by the specific `pdd` command as documented in `<pdd_readme>`. Handle global options like `--local`, `--strength`, `--temperature`, `--force`, `--verbose`, `--quiet`, `--output-cost`, `--review-examples` if they are included in the tool definitions and passed in the `arguments` dict. Global options go before the command arguments.
5.  Call the imported `run_pdd_command` function from the `.runner` module, passing the constructed command list and `await`ing the result.
6.  Receive the `PddResult` object from `run_pdd_command`.
7.  Construct an `mcp.types.CallToolResult` object:
    *   Set `isError` to `not pdd_result.success`.
    *   If `pdd_result.success` is `True`, set the `content` field to a list containing one `mcp.types.TextContent` object whose `text` field is `pdd_result.stdout`.
    *   If `pdd_result.success` is `False`, set the `content` field to a list containing one `mcp.types.TextContent` object whose `text` field is `pdd_result.stderr`. You might consider prepending `stdout` to the error message if it provides useful context (e.g., `f"STDOUT:\n{pdd_result.stdout}\n\nSTDERR:\n{pdd_result.stderr}"`).
8.  Return the created `mcp.types.CallToolResult` object.
9.  Include clear type hints and docstrings for each handler function explaining its purpose and arguments.

**Code Structure Example (Illustrative):**

```python
"""
MCP tool handlers for executing PDD CLI commands.
"""

import logging
import mcp.types as types
from typing import Dict, List, Any

# Assume runner module provides these (adjust import path if necessary)
from .runner import run_pdd_command, PddResult

logger = logging.getLogger(__name__)

# --- Tool Handlers ---

async def handle_pdd_generate(arguments: Dict[str, Any]) -> types.CallToolResult:
    """
    Handles the 'pdd-generate' MCP tool call by executing the 'pdd generate' command.
    """
    logger.info("Handling pdd-generate tool call with arguments: %s", arguments)
    cmd_list = ['pdd', 'generate']

    # Required arguments
    prompt_file = arguments.get('prompt_file')
    if not prompt_file:
         # This ideally shouldn't happen if schema validation works
         return types.CallToolResult(isError=True, content=[types.TextContent(text="Missing required argument: prompt_file")])
    cmd_list.append(prompt_file) # Positional argument

    # Optional arguments
    if arguments.get('output'):
        cmd_list.extend(['--output', arguments['output']])
    if arguments.get('strength') is not None:
        cmd_list.extend(['--strength', str(arguments['strength'])])
    if arguments.get('temperature') is not None:
        cmd_list.extend(['--temperature', str(arguments['temperature'])])

    # Boolean flags / Global Options
    if arguments.get('local'):
        cmd_list.append('--local')
    if arguments.get('force'):
        cmd_list.append('--force')
    if arguments.get('verbose'):
         cmd_list.append('--verbose')
    if arguments.get('quiet'):
         cmd_list.append('--quiet')
    if arguments.get('output_cost'):
         cmd_list.extend(['--output-cost', arguments['output_cost']])
    if arguments.get('review_examples'):
         cmd_list.append('--review-examples')


    # Execute the command
    pdd_result: PddResult = await run_pdd_command(cmd_list)

    # Format the result
    if pdd_result.success:
        content = [types.TextContent(text=pdd_result.stdout)]
        is_error = False
        logger.info("pdd generate succeeded.")
    else:
        error_text = f"PDD command failed with exit code {pdd_result.exit_code}.\nSTDERR:\n{pdd_result.stderr}"
        # Optionally include stdout for context on failure
        # if pdd_result.stdout:
        #    error_text = f"STDOUT:\n{pdd_result.stdout}\n\n{error_text}"
        content = [types.TextContent(text=error_text)]
        is_error = True
        logger.error("pdd generate failed.")

    return types.CallToolResult(content=content, isError=is_error)
```

% Here is how to use the runner module:
<runner_example>
<include>context/runner_example.py</include>
</runner_example>

% Here is how to use the definitions module:
<definitions_example>
<include>context/definitions_example.py</include>
</definitions_example>

% Generate the complete Python code for *all* the handler functions listed in step 2 (`handle_pdd_generate`, `handle_pdd_example`, `handle_pdd_test`, etc.). Follow the pattern demonstrated in the `handle_pdd_generate` example, adapting the command list (`cmd_list`) construction based on the specific arguments and flags for each corresponding PDD command as documented in the PDD CLI README. Do not stop after generating only one handler; ensure all functions listed in step 2 are fully implemented.