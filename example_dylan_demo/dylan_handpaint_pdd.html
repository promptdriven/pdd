<!DOCTYPE html>
<html>
<head>
    <title>Hand Tracking Drawing</title>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000; /* Fallback background */
        }
        #output_canvas {
            display: block; /* Remove extra space below canvas */
            width: 100vw;
            height: 100vh;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        /* Hidden video element */
        #video_feed {
            display: none;
        }
    </style>
</head>
<body>
    <div class="info">
        Mode: <span id="mode_status">None</span><br>
        Open Palm: Erase | Pointed Index: Draw
    </div>

    <!-- Video element to capture webcam feed -->
    <video id="video_feed" playsinline style="transform: scaleX(-1);"></video>

    <!-- Canvas for Three.js rendering (video background, skeleton, drawing) -->
    <canvas id="output_canvas"></canvas>

    <!-- MediaPipe Hands and Three.js libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous"></script>

    <script type="module">
        // Ensure THREE is available
        if (typeof THREE === 'undefined') {
            console.error("Three.js not loaded!");
        }

        // DOM Elements
        const videoElement = document.getElementById('video_feed');
        const canvasElement = document.getElementById('output_canvas');
        const modeStatusElement = document.getElementById('mode_status');

        // --- Three.js Setup ---
        let scene, camera, renderer, videoTexture;
        let canvasWidth, canvasHeight;
        
        // Drawing related variables
        let currentMode = 'none'; // 'draw', 'erase', 'none'
        let isDrawingActive = false; // True if currently drawing a line
        let activeLine = null; // The THREE.Line object being drawn
        let currentLinePoints = []; // Points for the active line
        const drawnLines = []; // Array to store all completed lines
        const Z_OFFSET_DRAWING = -10; // Fixed Z offset for drawing plane
        const Z_SCALE_SKELETON = -300; // Scale factor for skeleton depth

        // Skeleton related variables
        let skeletonGroup;


        function initThreeJS() {
            scene = new THREE.Scene();

            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;

            // Orthographic camera for 2.5D effect
            camera = new THREE.OrthographicCamera(
                canvasWidth / -2, canvasWidth / 2,
                canvasHeight / 2, canvasHeight / -2,
                1, 1000
            );
            camera.position.z = 500; // Position camera to see origin and negative Z values

            renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true });
            renderer.setSize(canvasWidth, canvasHeight);

            // Video texture for background
            // Video Texture Setup (Camera Feed)
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBFormat;
            scene.background = videoTexture;

            skeletonGroup = new THREE.Group();
            scene.add(skeletonGroup);

            // Handle window resize
            window.addEventListener('resize', () => {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                
                camera.left = canvasWidth / -2;
                camera.right = canvasWidth / 2;
                camera.top = canvasHeight / 2;
                camera.bottom = canvasHeight / -2;
                camera.updateProjectionMatrix();
                
                renderer.setSize(canvasWidth, canvasHeight);
            });
        }

        // --- MediaPipe Hands Setup ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResultsMediaPipe);

        // --- Camera Setup ---
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    // Adjust canvas aspect ratio to match video once metadata is loaded
                    // This ensures the Three.js scene matches the video proportions
                    const videoAspectRatio = videoElement.videoWidth / videoElement.videoHeight;
                    canvasHeight = canvasWidth / videoAspectRatio;
                    
                    // Update camera for new aspect ratio
                    camera.left = canvasWidth / -2;
                    camera.right = canvasWidth / 2;
                    camera.top = canvasHeight / 2; // Recalculate based on new canvasHeight
                    camera.bottom = canvasHeight / -2;
                    camera.updateProjectionMatrix();
                    renderer.setSize(canvasWidth, canvasHeight); // This might cause letterboxing if canvas is 100vw/vh

                    // Start processing frames
                    requestAnimationFrame(sendVideoFrameToMediaPipe);
                };
            } catch (err) {
                console.error("Error accessing webcam:", err);
                alert("Error accessing webcam. Please ensure permissions are granted.");
            }
        }
        
        async function sendVideoFrameToMediaPipe() {
            if (videoElement.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                 try {
                    await hands.send({ image: videoElement });
                } catch (error) {
                    console.error("Error sending frame to MediaPipe:", error);
                }
            }
            requestAnimationFrame(sendVideoFrameToMediaPipe);
        }


        // --- Gesture Recognition and Logic ---
        function getTipToMCPDistance(landmarks, tipIndex, mcpIndex) {
            const tip = landmarks[tipIndex];
            const mcp = landmarks[mcpIndex];
            if (!tip || !mcp) return 0;
            return Math.sqrt(Math.pow(tip.x - mcp.x, 2) + Math.pow(tip.y - mcp.y, 2) + Math.pow(tip.z - mcp.z, 2));
        }
        
        function isFingerExtended(landmarks, tipIndex, pipIndex) {
            // A finger is extended if its tip is "above" (smaller y) its PIP joint
            // landmarks are normalized, y=0 is top, y=1 is bottom
            if (!landmarks[tipIndex] || !landmarks[pipIndex]) return false;
            return landmarks[tipIndex].y < landmarks[pipIndex].y;
        }

        function isFingerCurled(landmarks, tipIndex, pipIndex, mcpIndex) {
            // A finger is curled if its tip is "below" (larger y) its PIP joint
            if (!landmarks[tipIndex] || !landmarks[pipIndex]) return false;
            // More robust: tip y > pip y, and pip y > mcp y (roughly)
            // Or tip is closer to MCP than PIP is to MCP in y
            return landmarks[tipIndex].y > landmarks[pipIndex].y && landmarks[tipIndex].y > landmarks[mcpIndex].y * 0.9; // Tip below PIP and somewhat close to MCP height
        }


        function onResultsMediaPipe(results) {
            // Clear previous skeleton
            while (skeletonGroup.children.length > 0) {
                const child = skeletonGroup.children[0];
                skeletonGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            let newMode = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const handLandmarks = results.multiHandLandmarks[0]; // Use the first detected hand

                // Draw MediaPipe Hand Skeleton
                // Landmark points (spheres)
                handLandmarks.forEach(landmark => {
                    const sphereGeo = new THREE.SphereGeometry(0.01 * canvasHeight, 8, 8); // Size relative to canvas height
                    const sphereMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                    const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
                    sphereMesh.position.set(
                        (landmark.x - 0.5) * canvasWidth,
                        (0.5 - landmark.y) * canvasHeight, // Invert Y
                        landmark.z * Z_SCALE_SKELETON
                    );
                    skeletonGroup.add(sphereMesh);
                });

                // Landmark connections (lines)
                if (window.HAND_CONNECTIONS) {
                    HAND_CONNECTIONS.forEach(connection => {
                        const startLm = handLandmarks[connection[0]];
                        const endLm = handLandmarks[connection[1]];
                        if (startLm && endLm) {
                            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    (startLm.x - 0.5) * canvasWidth,
                                    (0.5 - startLm.y) * canvasHeight,
                                    startLm.z * Z_SCALE_SKELETON
                                ),
                                new THREE.Vector3(
                                    (endLm.x - 0.5) * canvasWidth,
                                    (0.5 - endLm.y) * canvasHeight,
                                    endLm.z * Z_SCALE_SKELETON
                                )
                            ]);
                            const lineMat = new THREE.LineBasicMaterial({ color: 0x00cc00, linewidth: 2 });
                            const lineMesh = new THREE.Line(lineGeo, lineMat);
                            skeletonGroup.add(lineMesh);
                        }
                    });
                }


                // --- Gesture Detection for Drawing/Erasing ---
                // Landmark indices:
                // THUMB_TIP: 4, INDEX_FINGER_TIP: 8, MIDDLE_FINGER_TIP: 12, RING_FINGER_TIP: 16, PINKY_TIP: 20
                // THUMB_PIP: 2 (MCP for thumb), INDEX_FINGER_PIP: 6, MIDDLE_FINGER_PIP: 10, RING_FINGER_PIP: 14, PINKY_PIP: 18
                // INDEX_FINGER_MCP: 5, MIDDLE_FINGER_MCP: 9, RING_FINGER_MCP: 13, PINKY_MCP: 17

                const indexExtended = isFingerExtended(handLandmarks, 8, 6);
                const middleExtended = isFingerExtended(handLandmarks, 12, 10);
                const ringExtended = isFingerExtended(handLandmarks, 16, 14);
                const pinkyExtended = isFingerExtended(handLandmarks, 20, 18);
                const thumbExtended = isFingerExtended(handLandmarks, 4, 2); // Using MCP as PIP for thumb

                const middleCurled = isFingerCurled(handLandmarks, 12, 10, 9);
                const ringCurled = isFingerCurled(handLandmarks, 16, 14, 13);
                const pinkyCurled = isFingerCurled(handLandmarks, 20, 18, 17);


                if (indexExtended && middleCurled && ringCurled && pinkyCurled) {
                    newMode = 'draw';
                } else if (thumbExtended && indexExtended && middleExtended && ringExtended && pinkyExtended) {
                    newMode = 'erase';
                }


                // --- Drawing and Erasing Logic ---
                if (newMode === 'draw') {
                    const tipLandmark = handLandmarks[8]; // Index finger tip
                    const tipPos3D = new THREE.Vector3(
                        (tipLandmark.x - 0.5) * canvasWidth,
                        (0.5 - tipLandmark.y) * canvasHeight,
                        Z_OFFSET_DRAWING // Draw on a fixed Z plane
                    );

                    if (!isDrawingActive) { // Start of a new line
                        isDrawingActive = true;
                        currentLinePoints = [tipPos3D.x, tipPos3D.y, tipPos3D.z];
                        
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentLinePoints, 3));
                        
                        const material = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 3 }); // Magenta color for drawing
                        activeLine = new THREE.Line(geometry, material);
                        scene.add(activeLine);
                    } else if (activeLine) { // Continue drawing line
                        currentLinePoints.push(tipPos3D.x, tipPos3D.y, tipPos3D.z);
                        activeLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentLinePoints, 3));
                        activeLine.geometry.attributes.position.needsUpdate = true;
                        activeLine.geometry.computeBoundingSphere();
                    }
                } else if (isDrawingActive) { // If mode changed from draw or hand lost
                    isDrawingActive = false;
                    if (activeLine) {
                        if (currentLinePoints.length > 3) { // Only add if it has more than one point
                           drawnLines.push(activeLine);
                        } else { // Remove if too short
                           scene.remove(activeLine);
                           if(activeLine.geometry) activeLine.geometry.dispose();
                           if(activeLine.material) activeLine.material.dispose();
                        }
                        activeLine = null;
                    }
                    currentLinePoints = [];
                }


                if (newMode === 'erase') {
                    // Use center of palm (e.g., average of MCPs or landmark 9)
                    const palmCenterLandmark = handLandmarks[9]; // MIDDLE_FINGER_MCP
                    const palmPos3D = new THREE.Vector3(
                        (palmCenterLandmark.x - 0.5) * canvasWidth,
                        (0.5 - palmCenterLandmark.y) * canvasHeight,
                        Z_OFFSET_DRAWING // Erase on the same Z plane as drawing
                    );
                    const eraseRadius = 0.08 * canvasHeight; // Eraser size relative to canvas height

                    for (let i = drawnLines.length - 1; i >= 0; i--) {
                        const line = drawnLines[i];
                        const points = line.geometry.attributes.position.array;
                        let lineIntersects = false;
                        for (let j = 0; j < points.length; j += 3) {
                            const point = new THREE.Vector3(points[j], points[j+1], points[j+2]);
                            if (point.distanceTo(palmPos3D) < eraseRadius) {
                                lineIntersects = true;
                                break;
                            }
                        }
                        if (lineIntersects) {
                            scene.remove(line);
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                            drawnLines.splice(i, 1);
                        }
                    }
                }
                currentMode = newMode;

            } else { // No hand detected
                if (isDrawingActive) { // If was drawing and hand lost
                    isDrawingActive = false;
                    if (activeLine) {
                         if (currentLinePoints.length > 3) {
                           drawnLines.push(activeLine);
                        } else {
                           scene.remove(activeLine);
                           if(activeLine.geometry) activeLine.geometry.dispose();
                           if(activeLine.material) activeLine.material.dispose();
                        }
                        activeLine = null;
                    }
                    currentLinePoints = [];
                }
                currentMode = 'none';
            }
            modeStatusElement.textContent = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (videoTexture) {
                videoTexture.needsUpdate = true; // Important for VideoTexture
            }
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        initThreeJS();
        setupCamera(); // This will also start the MediaPipe processing loop via onloadedmetadata
        animate(); // Start Three.js rendering loop

    </script>
</body>
</html>