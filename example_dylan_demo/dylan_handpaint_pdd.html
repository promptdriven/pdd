<!DOCTYPE html>
<html>
<head>
    <title>Hand Tracking Drawing</title>
    <meta charset="utf-g">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        /* Video element is not directly visible, used as Three.js texture source */
        #webcam {
            display: none; /* Hidden as it's used as a texture */
        }
        #outputCanvas, #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #threeCanvas {
            z-index: 1; /* Three.js canvas for drawing and video background */
        }
        #outputCanvas {
            z-index: 2; /* MediaPipe canvas for skeleton, on top */
        }
        .controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
    <!-- MediaPipe CDN imports -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js CDN import -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="threeCanvas"></canvas> <!-- For Three.js rendering (video background + drawings) -->
        <canvas id="outputCanvas"></canvas> <!-- For MediaPipe skeleton -->
    </div>
    <div class="controls-info">
        Point Index Finger: Draw<br>
        Open Palm: Erase
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        import { drawConnectors, drawLandmarks } from 'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js';
        import { HAND_CONNECTIONS } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';

        const videoElement = document.getElementById('webcam');
        const outputCanvas = document.getElementById('outputCanvas'); // For MediaPipe skeleton
        const outputCtx = outputCanvas.getContext('2d');
        const threeCanvas = document.getElementById('threeCanvas'); // For Three.js scene

        let videoWidth, videoHeight;

        // --- Three.js Setup ---
        // Where the Three.js renderer is configured
        let scene, camera, renderer;
        let drawnLines = []; // Stores { points: Vector3[], threeLine: THREE.Line }
        let currentLinePoints = [];
        let currentThreeLine = null;
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 }); // Green lines
        
        let eraserMesh;
        const eraserRadius = 20; // pixels for eraser dot visual and logic
        const palmCenterLandmarkIndex = 9; // MIDDLE_FINGER_MCP
        const indexFingerTipLandmarkIndex = 8;

        function initThreeJS() {
            scene = new THREE.Scene();
            
            // Orthographic camera to match video dimensions
            // (0,0) will be top-left after transformations
            camera = new THREE.OrthographicCamera(0, videoWidth, 0, videoHeight, -100, 100);
            camera.position.set(videoWidth / 2, videoHeight / 2, 50); // Centered
            camera.lookAt(videoWidth / 2, videoHeight / 2, 0);
            // Adjust camera to make (0,0) top-left and y increasing downwards
            camera.left = 0;
            camera.right = videoWidth;
            camera.top = 0; // Y will be flipped by scaling projection matrix
            camera.bottom = videoHeight;
            camera.updateProjectionMatrix();
            // Flip Y axis for camera to match 2D canvas coordinates (0,0 at top-left)
            camera.projectionMatrix.scale(new THREE.Vector3(1, -1, 1));


            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true }); // alpha:true for transparency if not using video texture
            renderer.setSize(videoWidth, videoHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Where the camera feed is set up (unmirrored) using VideoTexture
            // Use video element as a texture for the scene background
            const videoTexture = new THREE.VideoTexture(videoElement);
            // The following lines unmirror the video texture if the source is mirrored
            videoTexture.wrapS = THREE.RepeatWrapping; // or ClampToEdgeWrapping if supported and preferred
            videoTexture.repeat.x = -1; // Flips the texture horizontally

            scene.background = videoTexture;

            // Eraser dot (initially hidden)
            // Where MediaPipe Hands landmarks used to position the palm dot
            const eraserGeometry = new THREE.CircleGeometry(eraserRadius / 2, 32); // Visual radius
            const eraserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7 });
            eraserMesh = new THREE.Mesh(eraserGeometry, eraserMaterial);
            eraserMesh.visible = false;
            eraserMesh.position.z = 1; // Ensure it's on top of lines
            scene.add(eraserMesh);
        }

        // --- MediaPipe Hands Setup ---
        // Where MediaPipe Hands is initialized
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        // --- Webcam Setup ---
        // Where the camera feed is set up
        const cameraHelper = new CameraUtils.Camera(videoElement, {
            onFrame: async () => {
                if (!videoWidth) { // First frame, setup canvases and Three.js
                    videoWidth = videoElement.videoWidth;
                    videoHeight = videoElement.videoHeight;
                    
                    outputCanvas.width = videoWidth;
                    outputCanvas.height = videoHeight;
                    threeCanvas.width = videoWidth;
                    threeCanvas.height = videoHeight;

                    initThreeJS();
                }
                await hands.send({ image: videoElement });
            },
            width: 640, // Request a common resolution
            height: 480
        });
        cameraHelper.start();


        let currentMode = 'none'; // 'draw', 'erase', 'none'

        function onResults(results) {
            if (!videoWidth || !renderer) return; // Ensure Three.js is initialized

            // Clear MediaPipe overlay canvas
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Process hand landmarks
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; // Assuming one hand

                // Draw skeleton on MediaPipe canvas
                // Coordinates need to be unmirrored for display
                // lm.x is from original (mirrored) stream. (1.0 - lm.x) maps to unmirrored view.
                const unmirroredLandmarks = landmarks.map(lm => ({
                    ...lm,
                    x: (1.0 - lm.x) * outputCanvas.width,
                    y: lm.y * outputCanvas.height,
                    // z is not directly used for 2D drawing here but good to keep
                }));

                // Where MediaPipe Hands landmarks used to position the skeleton
                drawConnectors(outputCtx, unmirroredLandmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(outputCtx, unmirroredLandmarks, { color: '#FF0000', lineWidth: 1, radius: 3 });
                
                // Get specific landmarks for gestures and drawing (in original mirrored normalized coords)
                const palmCenter = landmarks[palmCenterLandmarkIndex];
                const indexTip = landmarks[indexFingerTipLandmarkIndex];

                // Convert to unmirrored pixel coordinates for Three.js
                const palmCenterCoords = {
                    x: (1.0 - palmCenter.x) * videoWidth,
                    y: palmCenter.y * videoHeight
                };
                const indexTipCoords = {
                    x: (1.0 - indexTip.x) * videoWidth,
                    y: indexTip.y * videoHeight
                };

                // --- Gesture Detection ---
                // Where the logic distinguishes “draw” vs. “erase” modes
                const isPointing = checkIndexFingerPointing(landmarks);
                const isOpenPalm = checkOpenPalm(landmarks);

                let newMode = 'none';
                if (isPointing) {
                    newMode = 'draw';
                } else if (isOpenPalm) {
                    newMode = 'erase';
                }

                if (currentMode === 'draw' && newMode !== 'draw') { // Exiting draw mode
                    if (currentThreeLine) {
                        if (currentLinePoints.length < 2) { // Not enough points for a line
                           scene.remove(currentThreeLine);
                        } else {
                           // Finalize line geometry
                           const finalGeometry = new THREE.BufferGeometry().setFromPoints(currentLinePoints);
                           currentThreeLine.geometry.dispose(); // Dispose old geometry
                           currentThreeLine.geometry = finalGeometry;
                           drawnLines.push({ points: [...currentLinePoints], threeLine: currentThreeLine });
                        }
                        currentThreeLine = null;
                    }
                    currentLinePoints = [];
                }
                currentMode = newMode;

                // --- Handle Drawing/Erasing in Three.js ---
                // Where the Three.js renderer is configured to draw lines and erase segments
                if (currentMode === 'draw') {
                    eraserMesh.visible = false;
                    const pointVec = new THREE.Vector3(indexTipCoords.x, indexTipCoords.y, 0);
                    
                    if (!currentThreeLine) { // Start of a new line segment
                        currentLinePoints.push(pointVec); // Add first point
                        // Create a line with minimal points, will be updated
                        const geometry = new THREE.BufferGeometry().setFromPoints([pointVec, pointVec.clone()]);
                        currentThreeLine = new THREE.Line(geometry, lineMaterial);
                        scene.add(currentThreeLine);
                    } else {
                        currentLinePoints.push(pointVec);
                        // Update existing line geometry
                        currentThreeLine.geometry.dispose(); // Important to dispose old geometry
                        currentThreeLine.geometry = new THREE.BufferGeometry().setFromPoints(currentLinePoints);
                    }
                } else if (currentMode === 'erase') {
                    eraserMesh.position.set(palmCenterCoords.x, palmCenterCoords.y, 1);
                    eraserMesh.visible = true;
                    eraseSegments(palmCenterCoords, eraserRadius);
                } else { // 'none' mode
                    eraserMesh.visible = false;
                }

            } else { // No hand detected
                if (currentMode === 'draw' && currentThreeLine) { // Finalize line if hand disappears
                     if (currentLinePoints.length < 2) {
                        scene.remove(currentThreeLine);
                     } else {
                        const finalGeometry = new THREE.BufferGeometry().setFromPoints(currentLinePoints);
                        currentThreeLine.geometry.dispose();
                        currentThreeLine.geometry = finalGeometry;
                        drawnLines.push({ points: [...currentLinePoints], threeLine: currentThreeLine });
                     }
                }
                currentLinePoints = [];
                currentThreeLine = null;
                currentMode = 'none';
                eraserMesh.visible = false;
            }
            
            renderer.render(scene, camera);
            outputCtx.restore();
        }

        function checkIndexFingerPointing(landmarks) {
            const tip = landmarks[8];    // INDEX_FINGER_TIP
            const pip = landmarks[6];    // INDEX_FINGER_PIP
            const mcp = landmarks[5];    // INDEX_FINGER_MCP

            const middleTip = landmarks[12]; // MIDDLE_FINGER_TIP
            const middlePip = landmarks[10]; // MIDDLE_FINGER_PIP
            
            const ringTip = landmarks[16];   // RING_FINGER_TIP
            const ringPip = landmarks[14];   // RING_FINGER_PIP

            const pinkyTip = landmarks[20];  // PINKY_FINGER_TIP
            const pinkyPip = landmarks[18];  // PINKY_FINGER_PIP

            // Index finger extended (tip is "above" PIP, MCP in normalized image coords)
            const indexExtended = tip.y < pip.y && pip.y < mcp.y;
            // Other fingers curled (tips are "below" PIPs)
            const middleCurled = middleTip.y > middlePip.y;
            const ringCurled = ringTip.y > ringPip.y;
            const pinkyCurled = pinkyTip.y > pinkyPip.y;
            
            return indexExtended && middleCurled && ringCurled && pinkyCurled;
        }

        function checkOpenPalm(landmarks) {
            // Check if all fingertips are extended (further from wrist or "above" their PIP joints)
            const wrist = landmarks[0];
            const fingerTips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
            const fingerPips = [landmarks[2], landmarks[6], landmarks[10], landmarks[14], landmarks[18]]; // Using PIPs

            let extendedFingers = 0;
            for (let i = 0; i < fingerTips.length; i++) {
                // Finger is extended if tip.y < pip.y (in normalized image coordinates where y decreases upwards)
                if (fingerTips[i].y < fingerPips[i].y) {
                    extendedFingers++;
                }
            }
            return extendedFingers >= 4; // Allow for some flexibility, e.g. thumb might not be perfectly "up"
        }

        function eraseSegments(eraserPosVec2, radius) {
            const eraserCenter = new THREE.Vector2(eraserPosVec2.x, eraserPosVec2.y);
        
            for (let i = drawnLines.length - 1; i >= 0; i--) {
                const lineObj = drawnLines[i];
                const originalPoints = lineObj.points; // These are Vector3
                let needsUpdate = false;
                
                const newPointGroups = [];
                let currentGroup = [];

                if (originalPoints.length < 2) {
                    scene.remove(lineObj.threeLine);
                    lineObj.threeLine.geometry.dispose();
                    drawnLines.splice(i, 1);
                    continue;
                }

                for (let j = 0; j < originalPoints.length; j++) {
                    const p1 = originalPoints[j];
                    let p2 = (j + 1 < originalPoints.length) ? originalPoints[j+1] : null;

                    if (currentGroup.length === 0) {
                        currentGroup.push(p1.clone());
                    }

                    if (p2) {
                        const segStart = new THREE.Vector2(p1.x, p1.y);
                        const segEnd = new THREE.Vector2(p2.x, p2.y);
                        
                        if (distancePointToSegment(eraserCenter, segStart, segEnd) < radius) {
                            // Segment is hit by eraser
                            needsUpdate = true;
                            if (currentGroup.length >= 2) { // Finalize current group before break
                                newPointGroups.push(currentGroup);
                            }
                            currentGroup = []; // Start a new group after the erased segment
                        } else {
                            // Segment not hit, continue current group
                            currentGroup.push(p2.clone());
                        }
                    }
                }
                // Add the last group if it has points
                if (currentGroup.length >= 2) {
                    newPointGroups.push(currentGroup);
                }


                if (needsUpdate) {
                    scene.remove(lineObj.threeLine);
                    lineObj.threeLine.geometry.dispose();
                    drawnLines.splice(i, 1); // Remove original line

                    newPointGroups.forEach(groupPoints => {
                        if (groupPoints.length >= 2) {
                            const newGeometry = new THREE.BufferGeometry().setFromPoints(groupPoints);
                            const newLine = new THREE.Line(newGeometry, lineMaterial);
                            scene.add(newLine);
                            drawnLines.push({ points: groupPoints, threeLine: newLine });
                        }
                    });
                }
            }
        }
        
        // Helper function: distance from a point to a line segment
        function distancePointToSegment(point, segA, segB) {
            const l2 = segA.distanceToSquared(segB);
            if (l2 === 0) return point.distanceTo(segA);
            
            let t = ((point.x - segA.x) * (segB.x - segA.x) + (point.y - segA.y) * (segB.y - segA.y)) / l2;
            t = Math.max(0, Math.min(1, t)); // Clamp t to the segment

            const projection = new THREE.Vector2(
                segA.x + t * (segB.x - segA.x),
                segA.y + t * (segB.y - segA.y)
            );
            return point.distanceTo(projection);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) { // Check if video is loaded
                videoWidth = videoElement.videoWidth; // Use actual video dimensions
                videoHeight = videoElement.videoHeight;

                // Update canvas sizes
                outputCanvas.width = videoWidth;
                outputCanvas.height = videoHeight;
                threeCanvas.width = videoWidth;
                threeCanvas.height = videoHeight;

                if (renderer && camera) {
                    // Update Three.js camera and renderer
                    camera.right = videoWidth;
                    camera.bottom = videoHeight;
                    camera.updateProjectionMatrix();
                    // Flip Y axis for camera
                    camera.projectionMatrix.scale(new THREE.Vector3(1, -1, 1));

                    renderer.setSize(videoWidth, videoHeight);
                }
            }
        });

    </script>
</body>
</html>