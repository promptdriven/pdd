<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Drawing</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Fallback if video doesn't load */
        }
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video feed */
            z-index: 1;
        }
        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #mediapipe_canvas {
            z-index: 2; /* MediaPipe skeleton and palm dot */
            pointer-events: none; /* Allow interactions with Three.js canvas */
        }
        #three_canvas {
            z-index: 3; /* Three.js drawing layer */
        }
    </style>
    <!-- MediaPipe and Three.js libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="mediapipe_canvas" class="output_canvas"></canvas>
    <canvas id="three_canvas" class="output_canvas"></canvas>

    <script type="module">
        // Import Three.js
        import * as THREE from 'three';

        // Get DOM elements
        const videoElement = document.getElementById('webcam');
        const mediapipeCanvas = document.getElementById('mediapipe_canvas');
        const mediapipeCtx = mediapipeCanvas.getContext('2d');
        const threeCanvas = document.getElementById('three_canvas');

        // Global variables
        let hands;
        let camera;
        let renderer, scene, threeCamera;
        
        let currentGesture = 'none'; // 'draw', 'erase', 'none'
        let isDrawingLine = false;
        let currentLinePoints = [];
        let activeLineMesh = null;
        const drawnLines = []; // Stores Three.js line meshes

        const ERASER_RADIUS = 25; // pixels for eraser size
        const LINE_COLOR = 0xff00ff; // Magenta
        const LINE_WIDTH = 3;


        // --- 1. CAMERA FEED SETUP ---
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    // Set canvas sizes once video dimensions are known
                    mediapipeCanvas.width = videoElement.videoWidth;
                    mediapipeCanvas.height = videoElement.videoHeight;
                    threeCanvas.width = videoElement.videoWidth;
                    threeCanvas.height = videoElement.videoHeight;
                    
                    // Initialize MediaPipe and Three.js after camera is ready
                    initializeMediaPipe();
                    initializeThreeJS();
                    startProcessing();
                };
            } catch (err) {
                console.error("Error accessing webcam:", err);
                alert("Could not access webcam. Please ensure permissions are granted and no other application is using it.");
            }
        }

        // --- 2. MEDIAPIPE HANDS INITIALIZATION ---
        function initializeMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6, // Increased for better stability
                minTrackingConfidence: 0.6, // Increased for better stability
                selfieMode: true // Crucial for mirrored video
            });
            hands.onResults(onMediaPipeResults);
        }

        function startProcessing() {
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    if (videoElement.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
                         await hands.send({ image: videoElement });
                    }
                },
                width: videoElement.videoWidth,
                height: videoElement.videoHeight
            });
            camera.start();
        }
        
        // --- 3. THREE.JS INITIALIZATION ---
        function initializeThreeJS() {
            renderer = new THREE.WebGLRenderer({
                canvas: threeCanvas,
                alpha: true // Transparent background
            });
            renderer.setSize(threeCanvas.width, threeCanvas.height);
            renderer.setClearColor(0x000000, 0); // Transparent

            scene = new THREE.Scene();
            
            // Orthographic camera for 2D drawing feel
            threeCamera = new THREE.OrthographicCamera(
                0, threeCanvas.width, // left, right
                0, threeCanvas.height, // top, bottom (0,0 is bottom-left)
                1, 1000 // near, far
            );
            threeCamera.position.z = 500;
            // Adjust camera so (0,0) is top-left, matching canvas/video coordinates
            threeCamera.left = 0;
            threeCamera.right = threeCanvas.width;
            threeCamera.top = 0; // Y positive is downwards
            threeCamera.bottom = threeCanvas.height;
            threeCamera.updateProjectionMatrix();

            animateThreeJS();
        }

        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);
            renderer.render(scene, threeCamera);
        }

        // --- MEDIAPIPE RESULTS PROCESSING ---
        function onMediaPipeResults(results) {
            mediapipeCtx.clearRect(0, 0, mediapipeCanvas.width, mediapipeCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; // Assuming one hand

                // Draw hand skeleton
                drawConnectors(mediapipeCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                drawLandmarks(mediapipeCtx, landmarks, { color: '#FF0000', lineWidth: 2, radius: 3 });

                // Calculate palm center (using middle finger MCP: landmark 9)
                const palmCenterLandmark = landmarks[9];
                const palmCenterX = palmCenterLandmark.x * mediapipeCanvas.width;
                const palmCenterY = palmCenterLandmark.y * mediapipeCanvas.height;

                // Draw dot at the middle of the palm
                mediapipeCtx.beginPath();
                mediapipeCtx.arc(palmCenterX, palmCenterY, 10, 0, 2 * Math.PI);
                mediapipeCtx.fillStyle = 'blue';
                mediapipeCtx.fill();
                
                // Convert palm center to Three.js coordinates for eraser
                const palmCenterThree = {
                    x: palmCenterLandmark.x * threeCanvas.width,
                    y: palmCenterLandmark.y * threeCanvas.height 
                };

                // --- GESTURE DETECTION & DRAWING/ERASING LOGIC ---
                detectGestureAndAct(landmarks, palmCenterThree);

            } else {
                // No hand detected, stop any active drawing
                if (isDrawingLine) {
                    finishLine();
                }
                currentGesture = 'none';
            }
        }

        function detectGestureAndAct(landmarks, palmCenterThree) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const indexPip = landmarks[6];
            const indexMcp = landmarks[5];
            const middleTip = landmarks[12];
            const middlePip = landmarks[10];
            const middleMcp = landmarks[9];
            const ringTip = landmarks[16];
            const ringPip = landmarks[14];
            const ringMcp = landmarks[13];
            const pinkyTip = landmarks[20];
            const pinkyPip = landmarks[18];
            const pinkyMcp = landmarks[17];

            // Simple gesture detection (relative Y positions, smaller Y is higher on screen)
            // These checks assume hand is mostly upright. More robust checks would use angles or distances.
            const isIndexExtended = indexTip.y < indexPip.y && indexPip.y < indexMcp.y;
            const isMiddleExtended = middleTip.y < middlePip.y && middlePip.y < middleMcp.y;
            const isRingExtended = ringTip.y < ringPip.y && ringPip.y < ringMcp.y;
            const isPinkyExtended = pinkyTip.y < pinkyPip.y && pinkyPip.y < pinkyMcp.y;

            const isMiddleCurled = middleTip.y > middlePip.y;
            const isRingCurled = ringTip.y > ringPip.y;
            const isPinkyCurled = pinkyTip.y > pinkyPip.y;
            
            let previousGesture = currentGesture;
            currentGesture = 'none'; // Reset gesture for this frame

            // Check for Open Palm (Erase Mode)
            if (isIndexExtended && isMiddleExtended && isRingExtended && isPinkyExtended) {
                currentGesture = 'erase';
            }
            // Check for Pointing Index Finger (Draw Mode) - higher priority than erase if both conditions met
            else if (isIndexExtended && isMiddleCurled && isRingCurled && isPinkyCurled) {
                currentGesture = 'draw';
            }
            
            // Handle transitions and actions
            if (previousGesture === 'draw' && currentGesture !== 'draw') {
                finishLine(); // Finish line if we were drawing and now stopped
            }

            if (currentGesture === 'draw') {
                const indexTipThree = {
                    x: indexTip.x * threeCanvas.width,
                    y: indexTip.y * threeCanvas.height
                };
                handleDrawing(indexTipThree);
            } else if (currentGesture === 'erase') {
                handleErasing(palmCenterThree);
            }
        }

        // --- DRAWING LOGIC ---
        function handleDrawing(point) {
            if (!isDrawingLine) {
                isDrawingLine = true;
                currentLinePoints = [new THREE.Vector3(point.x, point.y, 0)];
                
                const material = new THREE.LineBasicMaterial({ color: LINE_COLOR, linewidth: LINE_WIDTH });
                // Note: linewidth > 1 might not be supported on all systems/drivers for LineBasicMaterial.
                // It often defaults to 1. For thicker lines, Line2 from three/examples/jsm/lines is needed.
                
                const geometry = new THREE.BufferGeometry().setFromPoints(currentLinePoints);
                activeLineMesh = new THREE.Line(geometry, material);
                scene.add(activeLineMesh);
                drawnLines.push(activeLineMesh);
            } else {
                currentLinePoints.push(new THREE.Vector3(point.x, point.y, 0));
                if (activeLineMesh && currentLinePoints.length > 1) {
                    activeLineMesh.geometry.setFromPoints(currentLinePoints);
                    activeLineMesh.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        function finishLine() {
            isDrawingLine = false;
            activeLineMesh = null; // The line is already in drawnLines and scene
            currentLinePoints = [];
        }

        // --- ERASING LOGIC ---
        function handleErasing(palmCenter) {
             // Iterate in reverse for safe removal
            for (let i = drawnLines.length - 1; i >= 0; i--) {
                const line = drawnLines[i];
                const points = line.geometry.attributes.position;
                let erased = false;
                for (let j = 0; j < points.count; j++) {
                    const linePoint = new THREE.Vector3().fromBufferAttribute(points, j);
                    // Check distance from palm center to this point on the line
                    const distance = Math.sqrt(
                        Math.pow(linePoint.x - palmCenter.x, 2) +
                        Math.pow(linePoint.y - palmCenter.y, 2)
                    );
                    if (distance < ERASER_RADIUS) {
                        scene.remove(line);
                        line.geometry.dispose();
                        line.material.dispose();
                        drawnLines.splice(i, 1); // Remove from array
                        erased = true;
                        break; // Erased this line, move to next frame or check next line
                    }
                }
                // if (erased) break; // Optional: erase only one line per frame for performance
            }
        }

        // --- MAIN EXECUTION ---
        window.addEventListener('DOMContentLoaded', () => {
            setupCamera();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;

                // Update video element style if it's not fitting correctly (optional)
                // videoElement.style.width = `${newWidth}px`;
                // videoElement.style.height = `${newHeight}px`;

                // Update canvas dimensions based on video aspect ratio or window size
                // This example keeps canvas size tied to video's intrinsic size
                // If you want full window, then update mediapipeCanvas & threeCanvas sizes here
                // and also the Three.js camera and renderer.
                
                if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                    mediapipeCanvas.width = videoElement.videoWidth;
                    mediapipeCanvas.height = videoElement.videoHeight;
                    threeCanvas.width = videoElement.videoWidth;
                    threeCanvas.height = videoElement.videoHeight;

                    if (renderer && threeCamera) {
                        renderer.setSize(threeCanvas.width, threeCanvas.height);
                        threeCamera.right = threeCanvas.width;
                        threeCamera.bottom = threeCanvas.height;
                        threeCamera.updateProjectionMatrix();
                    }
                }
            });
        });

    </script>
</body>
</html>