<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Tracking Drawing with MediaPipe and Three.js</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #282c34;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent scrollbars from flashing during load */
        }
        #loadingMessage {
            font-size: 1.5em;
            text-align: center;
        }
        #mainContainer {
            position: relative;
            /* Dimensions will be set by JavaScript */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000; /* Fallback if video doesn't load */
        }
        #mainContainer canvas { /* Style the Three.js canvas */
            display: block; /* Removes bottom space under canvas */
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 15px;
            background-color: rgba(40, 44, 52, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 100;
        }
        #controls button {
            padding: 8px 12px;
            background-color: #61dafb;
            color: #282c34;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        #controls button:hover {
            background-color: #4fa8c5;
        }
        #controls label {
            font-size: 14px;
        }
        #controls input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            padding: 0;
            border-radius: 4px;
            cursor: pointer;
        }
        #controls input[type="range"] {
            cursor: pointer;
        }
        /* Hide the actual video element used by MediaPipe */
        #input_video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadingMessage">
        <p>Loading Application...</p>
        <p>Please grant camera access when prompted.</p>
    </div>

    <div id="mainContainer" style="display: none;">
        <video id="input_video" playsinline></video>
        <!-- Three.js canvas will be appended here -->
    </div>

    <div id="controls" style="display: none;">
        <button id="clearButton">Clear</button>
        <label for="colorPicker">Color:</label>
        <input type="color" id="colorPicker" value="#61dafb">
        <label for="lineWidth">Width:</label>
        <input type="range" id="lineWidth" min="1" max="30" value="5">
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/controls/OrbitControls.js",
            "@tweenjs/tween.js": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.js"
        }
    }
    </script>

    <!-- MediaPipe CDN Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        const WEBCAM_WIDTH = 640; // Desired webcam resolution
        const WEBCAM_HEIGHT = 480;

        // DOM Elements
        const loadingMessageEl = document.getElementById('loadingMessage');
        const mainContainerEl = document.getElementById('mainContainer');
        const videoElement = document.getElementById('input_video');
        const controlsEl = document.getElementById('controls');
        const clearButtonEl = document.getElementById('clearButton');
        const colorPickerEl = document.getElementById('colorPicker');
        const lineWidthEl = document.getElementById('lineWidth');

        // Three.js variables
        let scene, camera, renderer;
        let videoPlane, drawingPlane, skeletonPlane;
        let videoTexture, drawingCanvas, drawingContext, drawingTexture;
        let skeletonCanvas, skeletonContext, skeletonTexture;

        // MediaPipe variables
        let hands, mpCamera;

        // Drawing state
        let lastKnownIndexFingerTip = null; // { x, y } in drawingCanvas coordinates
        let isDrawingActive = false;
        let strokeColor = '#61dafb';
        let strokeWidth = 5;

        // Erasing state
        let isErasingActive = false;
        let lastKnownErasePosition = null; // {x, y} in drawingCanvas coordinates
        const eraseRadius = 20; // Radius for erasing tool

        async function initializeApp() {
            try {
                setupThreeJS();
                setupMediaPipe();
                await startWebcam();
                setupEventListeners();

                mainContainerEl.style.display = 'block';
                controlsEl.style.display = 'flex';
                loadingMessageEl.style.display = 'none';
                
                animate();
            } catch (error) {
                console.error("Initialization failed:", error);
                loadingMessageEl.innerHTML = `<p>Error: ${error.message}</p><p>Please ensure camera access is granted and try refreshing.</p>`;
            }
        }

        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera (Orthographic for 2D-like view)
            camera = new THREE.OrthographicCamera(
                WEBCAM_WIDTH / -2, WEBCAM_WIDTH / 2,
                WEBCAM_HEIGHT / 2, WEBCAM_HEIGHT / -2,
                1, 1000
            );
            camera.position.z = 10;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WEBCAM_WIDTH, WEBCAM_HEIGHT);
            mainContainerEl.appendChild(renderer.domElement);
            mainContainerEl.style.width = `${WEBCAM_WIDTH}px`;
            mainContainerEl.style.height = `${WEBCAM_HEIGHT}px`;

            // Video Plane (background)
            videoTexture = new THREE.VideoTexture(videoElement);
            const videoGeometry = new THREE.PlaneGeometry(WEBCAM_WIDTH, WEBCAM_HEIGHT);
            const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
            videoPlane = new THREE.Mesh(videoGeometry, videoMaterial);
            videoPlane.scale.x = -1; // Mirror video
            videoPlane.position.z = 0;
            scene.add(videoPlane);

            // Skeleton Canvas & Texture (middle layer)
            skeletonCanvas = document.createElement('canvas');
            skeletonCanvas.width = WEBCAM_WIDTH;
            skeletonCanvas.height = WEBCAM_HEIGHT;
            skeletonContext = skeletonCanvas.getContext('2d');
            skeletonTexture = new THREE.CanvasTexture(skeletonCanvas);
            const skeletonGeometry = new THREE.PlaneGeometry(WEBCAM_WIDTH, WEBCAM_HEIGHT);
            const skeletonMaterial = new THREE.MeshBasicMaterial({ map: skeletonTexture, transparent: true });
            skeletonPlane = new THREE.Mesh(skeletonGeometry, skeletonMaterial);
            skeletonPlane.scale.x = -1; // Mirror skeleton to align with video
            skeletonPlane.position.z = 0.5; // Position between video and drawing
            scene.add(skeletonPlane);

            // Drawing Canvas & Texture (overlay)
            drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = WEBCAM_WIDTH;
            drawingCanvas.height = WEBCAM_HEIGHT;
            drawingContext = drawingCanvas.getContext('2d');
            drawingContext.lineCap = 'round';
            drawingContext.lineJoin = 'round';

            drawingTexture = new THREE.CanvasTexture(drawingCanvas);
            const drawingGeometry = new THREE.PlaneGeometry(WEBCAM_WIDTH, WEBCAM_HEIGHT);
            const drawingMaterial = new THREE.MeshBasicMaterial({ map: drawingTexture, transparent: true });
            drawingPlane = new THREE.Mesh(drawingGeometry, drawingMaterial);
            drawingPlane.scale.x = -1; // Mirror drawing to align with video
            drawingPlane.position.z = 1;
            scene.add(drawingPlane);
        }

        function setupMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onHandResults);
        }

        async function startWebcam() {
            return new Promise((resolve, reject) => {
                videoElement.onloadedmetadata = () => {
                    videoElement.width = WEBCAM_WIDTH;
                    videoElement.height = WEBCAM_HEIGHT;
                    console.log("Video metadata loaded, dimensions:", videoElement.videoWidth, videoElement.videoHeight);
                };

                mpCamera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (videoElement.readyState >= HTMLMediaElement.HAVE_METADATA) {
                             await hands.send({ image: videoElement });
                        }
                    },
                    width: WEBCAM_WIDTH,
                    height: WEBCAM_HEIGHT
                });

                mpCamera.start()
                    .then(() => {
                        console.log("Camera started successfully.");
                        resolve();
                    })
                    .catch(err => {
                        console.error("Failed to start camera:", err);
                        reject(new Error("Could not access webcam. Please check permissions."));
                    });
            });
        }

        function getNormalizedDistance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function isIndexFingerPointing(landmarks) {
            const wrist = landmarks[0];
            const indexTip = landmarks[8];
            const indexMcp = landmarks[5];
            const middleTip = landmarks[12];
            const middleMcp = landmarks[9];
            const ringTip = landmarks[16];
            const ringMcp = landmarks[13];
            const pinkyTip = landmarks[20];
            const pinkyMcp = landmarks[17];

            const palmSize = getNormalizedDistance(wrist, middleMcp);
            if (palmSize === 0) return false;

            const indexExtension = getNormalizedDistance(indexTip, indexMcp) / palmSize;
            const middleExtension = getNormalizedDistance(middleTip, middleMcp) / palmSize;
            const ringExtension = getNormalizedDistance(ringTip, ringMcp) / palmSize;
            const pinkyExtension = getNormalizedDistance(pinkyTip, pinkyMcp) / palmSize;

            const extendedThreshold = 0.5;
            const curledThreshold = 0.6;

            return indexExtension > extendedThreshold &&
                   middleExtension < curledThreshold &&
                   ringExtension < curledThreshold &&
                   pinkyExtension < curledThreshold;
        }

        function isOpenHand(landmarks) {
            const wrist = landmarks[0];
            const indexTip = landmarks[8];
            const indexMcp = landmarks[5];
            const middleTip = landmarks[12];
            const middleMcp = landmarks[9];
            const ringTip = landmarks[16];
            const ringMcp = landmarks[13];
            const pinkyTip = landmarks[20];
            const pinkyMcp = landmarks[17];

            const palmSize = getNormalizedDistance(wrist, middleMcp);
            if (palmSize === 0) return false;

            const extendedThreshold = 0.5;
            let extendedFingers = 0;
            if (getNormalizedDistance(indexTip, indexMcp) / palmSize > extendedThreshold) extendedFingers++;
            if (getNormalizedDistance(middleTip, middleMcp) / palmSize > extendedThreshold) extendedFingers++;
            if (getNormalizedDistance(ringTip, ringMcp) / palmSize > extendedThreshold) extendedFingers++;
            if (getNormalizedDistance(pinkyTip, pinkyMcp) / palmSize > extendedThreshold) extendedFingers++;
            
            return extendedFingers >= 3;
        }

        function onHandResults(results) {
            skeletonContext.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
            let currentGesture = null;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Draw skeleton for each detected hand
                for (const landmarks of results.multiHandLandmarks) {
                    window.drawConnectors(skeletonContext, landmarks, Hands.HAND_CONNECTIONS, 
                                       {color: '#00FF00', lineWidth: 2});
                    window.drawLandmarks(skeletonContext, landmarks, 
                                      {color: '#FF0000', lineWidth: 1, radius: 3});
                }

                const handLandmarksForGesture = results.multiHandLandmarks[0]; // Use the first hand for gestures

                if (isIndexFingerPointing(handLandmarksForGesture)) {
                    currentGesture = 'drawing';
                } else if (isOpenHand(handLandmarksForGesture)) {
                    currentGesture = 'erasing';
                }

                if (currentGesture === 'drawing') {
                    isDrawingActive = true;
                    isErasingActive = false;
                    const indexFingerTip = handLandmarksForGesture[8];
                    const currentX = indexFingerTip.x * drawingCanvas.width;
                    const currentY = indexFingerTip.y * drawingCanvas.height;

                    if (lastKnownIndexFingerTip) {
                        drawingContext.beginPath();
                        drawingContext.moveTo(lastKnownIndexFingerTip.x, lastKnownIndexFingerTip.y);
                        drawingContext.lineTo(currentX, currentY);
                        drawingContext.strokeStyle = strokeColor;
                        drawingContext.lineWidth = strokeWidth;
                        drawingContext.stroke();
                        drawingTexture.needsUpdate = true;
                    }
                    lastKnownIndexFingerTip = { x: currentX, y: currentY };
                    lastKnownErasePosition = null; // Reset erase position

                } else if (currentGesture === 'erasing') {
                    isDrawingActive = false;
                    isErasingActive = true;
                    
                    // Use average of fingertips or a central palm landmark for erasing position
                    const erasePointX = handLandmarksForGesture[9].x * drawingCanvas.width; // Middle finger MCP (landmark 9)
                    const erasePointY = handLandmarksForGesture[9].y * drawingCanvas.height;

                    drawingContext.globalCompositeOperation = 'destination-out';
                    drawingContext.beginPath();
                    if (lastKnownErasePosition) {
                        drawingContext.moveTo(lastKnownErasePosition.x, lastKnownErasePosition.y);
                        drawingContext.lineTo(erasePointX, erasePointY);
                        drawingContext.lineWidth = eraseRadius * 2; // Diameter for line
                        drawingContext.strokeStyle = 'rgba(0,0,0,1)';
                        drawingContext.stroke();
                    } else {
                        // Erase a circle at the first point or if hand is stationary
                        drawingContext.arc(erasePointX, erasePointY, eraseRadius, 0, Math.PI * 2, false);
                        drawingContext.fillStyle = 'rgba(0,0,0,1)';
                        drawingContext.fill();
                    }
                    drawingContext.globalCompositeOperation = 'source-over'; // Reset composite mode
                    drawingTexture.needsUpdate = true;
                    
                    lastKnownErasePosition = { x: erasePointX, y: erasePointY };
                    lastKnownIndexFingerTip = null; // Reset draw position

                } else { // No specific gesture for drawing/erasing, but hand is present
                    isDrawingActive = false;
                    isErasingActive = false;
                    lastKnownIndexFingerTip = null;
                    lastKnownErasePosition = null;
                }
            } else { // No hand detected
                isDrawingActive = false;
                isErasingActive = false;
                lastKnownIndexFingerTip = null;
                lastKnownErasePosition = null;
            }
            skeletonTexture.needsUpdate = true; // Update skeleton texture every frame it's processed
        }

        function setupEventListeners() {
            clearButtonEl.addEventListener('click', () => {
                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingTexture.needsUpdate = true;
            });

            colorPickerEl.addEventListener('input', (event) => {
                strokeColor = event.target.value;
            });

            lineWidthEl.addEventListener('input', (event) => {
                strokeWidth = parseInt(event.target.value, 10);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        initializeApp();

    </script>
</body>
</html>