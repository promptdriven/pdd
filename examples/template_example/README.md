# PDD Template Workflow Example

This example demonstrates using **PDD (Prompt-Driven Development)** to automatically generate complete applications from requirements using the template-based workflow.

## Why Use PDD Templates?

| Traditional Approach | PDD Template Approach |
|---------------------|----------------------|
| Manual module specification | Automated requirements analysis |
| Static docs that get outdated | Single source of truth (PRD) |
| No visualization | Auto-generated architecture diagrams |
| Specs drift from code | Regenerate anytime from PRD |

**Key benefits:**
- **One command** analyzes requirements and generates architecture
- **Standard JSON schema** for all architectures
- **Automatic Mermaid diagrams** for visualization
- **Works with any tech stack** - frontend, backend, mobile, data pipelines

## Quick Start

```bash
# Complete workflow (5 commands)
make clean                       # Remove previous artifacts
make template                    # Generate architecture from requirements
make prompts                     # Generate prompt templates
make USE_FORCE=yes sync_all      # Generate code and tests
make test                        # Verify all tests pass

# With Infisical (recommended)
infisical run -- make USE_FORCE=yes sync_all
```

## Core Concepts

The PDD template workflow uses a **three-stage pipeline**:

```
Requirements (PRD) → Architecture → Prompts → Code & Tests
                     (make template) (make prompts) (make sync_all)
```

1. **Architecture Template** (`make template`) - Analyzes your PRD → generates `architecture.json` + diagram
2. **Prompt Template** (`make prompts`) - Generates `.prompt` files for each module
3. **Sync** (`make sync_all`) - Generates code and tests from prompts

## Configuration

### Makefile Flags

| Flag | Default | Purpose |
|------|---------|---------|
| `USE_LOCAL` | `yes` | Use local API keys (no GitHub auth) |
| `USE_FORCE` | `no` | Skip all interactive prompts |

**Examples:**
```bash
# Recommended: local + no prompts
make USE_FORCE=yes sync_all

# With Infisical (auto-injects API keys)
infisical run -- make USE_FORCE=yes sync_all

# Explicit flags
make USE_LOCAL=yes USE_FORCE=yes sync_all

# Cloud mode (requires GitHub browser auth)
make USE_LOCAL=no sync_all
```

### API Key Setup

```bash
# Option 1: Export manually
export ANTHROPIC_API_KEY="your-key"
make sync_all

# Option 2: Use Infisical (recommended)
infisical run -- make sync_all

# Option 3: Create ~/.pdd/api-env
echo "ANTHROPIC_API_KEY=your-key" >> ~/.pdd/api-env
```

## Workflow Steps

### Step 1: Generate Architecture

```bash
make template
```

This runs `pdd generate --template architecture/architecture_json` with:
- **PRD File**: `EDIT_FILE_TOOL_README.md`
- **Output**: `architecture.json` + `architecture_diagram.html`

Open `architecture_diagram.html` in your browser to review the system design.

### Step 2: Generate Prompts

```bash
make prompts
```

Dynamically reads `architecture.json` and generates `.prompt` files in `prompts/` directory.

### Step 3: Sync Code & Tests

```bash
make USE_FORCE=yes sync_all
```

Processes all modules **in priority order** from `architecture.json`:
- **Executable code** (Python, JS, etc.) → `pdd sync` (generates code + tests)
- **Non-executable formats** (TOML, YAML, etc.) → `pdd generate` (no tests)

**Sync a single module:**
```bash
make USE_FORCE=yes sync MODULE=cli
make USE_FORCE=yes sync MODULE=core
```

### Step 4: Run Tests

```bash
make test
```

Runs `pytest tests/ -v` to verify all generated code passes.

## Iterative Refinement

The architecture and prompts generated by `make template` and `make prompts` are **starting points**, not final outputs. The built-in PDD templates provide a solid foundation, but you can refine them before generating code:

```
PRD → [make template] → architecture.json → [EDIT/REFINE] → final architecture
                                ↓
                        [make prompts]
                                ↓
                        prompts/*.prompt → [EDIT/REFINE] → final prompts
                                ↓
                        [make sync_all]
                                ↓
                        Generated code & tests
```

**Typical workflow:**
1. Run `make template` to generate initial architecture
2. Review `architecture.json` - adjust modules, dependencies, priorities
3. Run `make prompts` to generate initial prompts
4. Review prompts in `prompts/` - refine instructions, add context, clarify requirements
5. Run `make sync_all` to generate code from your refined prompts

**The prompts and architecture in this example** were initially generated with PDD's generic built-in templates, then manually refined to produce the final working application. You don't need to accept the first output - iterate until it matches your vision, then let PDD handle the code generation.

## Executable vs Non-Executable Formats

The Makefile automatically detects format type by naming convention:

| Type | Naming Pattern | Command | Tests |
|------|----------------|---------|-------|
| Executable | `cli_Python`, `api_TypeScript` | `pdd sync` | Yes |
| Non-executable | `config_TOML`, `schema_Prisma` | `pdd generate` | No |

**Non-executable formats:** TOML, YAML, JSON, XML, INI, CSV, Markdown, LaTeX, Prisma, etc.

## Common Workflows

### First-time setup
```bash
make clean
make template
make prompts
make USE_FORCE=yes sync_all
make test
pip install -e .
```

### Regenerate after updating requirements
```bash
# Edit EDIT_FILE_TOOL_README.md
make clean
make template
make prompts
make USE_FORCE=yes sync_all
make test
```

### Sync single module after prompt changes
```bash
# Edit prompts/cli_Python.prompt
make USE_FORCE=yes sync MODULE=cli
make test
```

### Regenerate prompts and sync specific module
```bash
make prompts
make USE_FORCE=yes sync MODULE=core
make test
```

### Fully automated with Infisical
```bash
infisical run -- make clean
infisical run -- make template
infisical run -- make prompts
infisical run -- make USE_FORCE=yes sync_all
make test
```

### CI/CD automation
```bash
export ANTHROPIC_API_KEY="${CI_SECRET_KEY}"
make clean
make USE_LOCAL=yes USE_FORCE=yes template
make USE_LOCAL=yes USE_FORCE=yes prompts
make USE_LOCAL=yes USE_FORCE=yes sync_all
make test
```

## Directory Structure

After running the complete workflow:

```
template_example/
├── EDIT_FILE_TOOL_README.md        # Requirements document (PRD)
├── Makefile                        # Build automation
├── README.md                       # This file
├── pyproject.toml                  # Package config (generated)
├── architecture.json               # Generated: make template
├── architecture_diagram.html       # Generated: make template
├── prompts/                        # Generated: make prompts
│   ├── pyproject_TOML.prompt
│   ├── cli_Python.prompt
│   ├── core_python.prompt
│   ├── cost_tracker_utility_Python.prompt
│   ├── cache_manager_utility_Python.prompt
│   ├── think_tool_capability_Python.prompt
│   └── __init___Python.prompt
├── src/                            # Generated: make sync_all
│   ├── edit_file_tool/             # Module source code
│   │   ├── __init__.py
│   │   ├── cli.py
│   │   ├── core.py
│   │   ├── cost_tracker_utility.py
│   │   ├── cache_manager_utility.py
│   │   └── think_tool_capability.py
│   ├── tests/                      # Generated unit tests
│   │   ├── test_cli.py
│   │   ├── test_core.py
│   │   ├── test_cost_tracker_utility.py
│   │   ├── test_cache_manager_utility.py
│   │   ├── test_think_tool_capability.py
│   │   └── test___init__.py
│   └── examples/                   # Generated usage examples
│       ├── cli_example.py
│       ├── core_example.py
│       └── ... other examples
├── logs/                           # Sync logs and cost reports
└── .pdd/                           # PDD metadata (auto-generated)
```

## What Are PDD Templates?

PDD templates are reusable prompt files with YAML front matter that define:
- **Metadata**: Name, description, version, tags
- **Variables**: Required/optional parameters with types
- **Output**: Default format and filename

### Template Variables

The architecture template accepts:
- **`PRD_FILE`** (required): Path to requirements document
- **`TECH_STACK_FILE`** (optional): Technical stack overview
- **`APP_NAME`** (optional): Application name
- **`DOC_FILES`** (optional): Additional documentation
- **`INCLUDE_FILES`** (optional): Source files to analyze

**View template info:**
```bash
make info           # Architecture template
make prompt-info    # Prompt generation template
```

## Using the Generated Application

After running `make sync_all`, you have a functional `edit-file-tool`:

### Installation

```bash
pip install -e .
edit-file --help
```

### CLI Usage

```bash
# Basic usage
edit-file myfile.py "add a docstring to the main function"

# With verbose output
edit-file --verbose myfile.py "refactor to use list comprehension"

# Different model
edit-file --model claude-sonnet-4-5@20250929 myfile.py "add type hints"

# Cache control
edit-file --cache always myfile.py "optimize queries"
edit-file --cache never myfile.py "fix bug on line 42"
```

### Vertex AI

To use Google Cloud Vertex AI, prefix model with `vertex_ai/`:

```bash
# Set required env vars
export VERTEX_CREDENTIALS="/path/to/credentials.json"
export VERTEX_PROJECT="your-gcp-project-id"
export VERTEX_LOCATION="vertex-location"

# Use Vertex AI model
edit-file --model vertex_ai/claude-sonnet-4-5@20250929 myfile.py "add error handling"
```

### CLI Options

| Option | Default | Description |
|--------|---------|-------------|
| `--verbose`, `-v` | off | Show cost breakdown |
| `--model` | `claude-haiku-4-5@20251001` | Model to use |
| `--cache` | `auto` | Cache mode: `auto`, `always`, `never` |

## Sync Options

The sync process uses defaults from `.pddrc` but supports:
- `--max-attempts` - Maximum fix attempts (default: 3)
- `--budget` - Max cost in USD (default: 20.0)
- `--skip-verify` - Skip functional verification
- `--skip-tests` - Skip test generation
- `--target-coverage` - Desired coverage % (default: 10.0)
- `--dry-run` - Show what would happen

## Troubleshooting

### GitHub Authentication Prompts

If you see GitHub auth prompts:
1. Ensure `USE_LOCAL=yes` (default)
2. Check API keys are available:
   ```bash
   infisical run -- env | grep API_KEY
   ```
3. Use force mode: `make USE_FORCE=yes sync_all`

### Sync Failures

- Check `logs/` for detailed error messages
- Try syncing individual module: `make sync MODULE=<name>`
- Verify prompt file exists in `prompts/`
