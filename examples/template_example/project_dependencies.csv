full_path,file_summary,date
"src/examples/__init___example.py","This Python script serves as a demonstration and example for the 'edit_file_tool' library, showcasing its high-precision file editing capabilities. The script begins by dynamically adjusting the system path to ensure the local package is importable. It then imports the core components: the 'edit_file' function, the 'EditTool20250124' class, and the package version. The main logic is contained within an asynchronous function named 'run_example'. This function first creates a temporary text file named 'demo_file.txt' with initial content. It then demonstrates the 'edit_file' function by performing a string replacement, changing 'World' to 'Software Engineer', and prints the updated content to the console. Additionally, the script attempts to instantiate the 'EditTool20250124' class, providing error handling in case of missing dependencies. Finally, the script performs cleanup by deleting the temporary test file. The code is structured to handle potential TypeErrors or general exceptions during the editing process, making it a robust reference for developers looking to integrate the library into their own asynchronous Python projects.",2025-12-31T00:36:14.998753+00:00
"src/examples/cache_manager_utility_example.py","The example script demonstrates how the cache manager utility decides whether to use caching for files of different sizes. After configuring logging, it creates a temporary workspace and defines small, medium, and large text files with increasing content lengths. The small file consists of a couple of simple text lines, the medium file contains multiple dummy function definitions and a loop snippet, while the large file includes repeated lines with numerical patterns. For each file, the script prints the file size, calls should_use_cache (with different use_cache arguments) from the edit_file_tool.cache_manager_utility module, and logs the returned decision. A missing file is also simulated to showcase the module’s warning behavior when the path does not exist, and a run illustrates the ValueError raised by passing an invalid use_cache mode. Cleanup removes the temporary workspace directory at the end. The script can be executed from the project root and adjusts sys.path so the module import works properly.",2025-12-30T00:42:09.491121+00:00
"src/examples/cli_example.py","The script is a stand-alone example for demonstrating how to use the edit_file_tool CLI directly from Python. It adjusts sys.path so the project root is importable, then defines two asynchronous fake edit implementations—one that simulates a successful edit and another that models a conflict failure. The demonstration function creates a temporary CLI demo file with placeholder content, swaps in the fake edit callbacks, and executes three scenarios: a successful edit that replaces the placeholder text, a conflict scenario to show error reporting, and an empty-instruction invocation to highlight validation. Throughout, the script prints status messages, captures exit codes, and handles unexpected exceptions without stopping execution. After all steps, it restores the original core.edit_file implementation, removes the temporary file, and prints cleanup status. When run as __main__, the script runs the demonstrate_operations function, providing an illustrative flow for CLI usage, error handling, and cleanup when editing files through the edit_file_tool package.",2025-12-30T19:45:39.882881+00:00
"src/examples/core_example.py","This Python script serves as a demonstration for utilizing the `edit_file` function from the `edit_file_tool.core` library. It outlines a complete workflow for programmatically editing a file using Claude models. The script begins by validating the presence of the `ANTHROPIC_API_KEY` environment variable and dynamically locating or creating a target text file named `sample_target.txt` within the script's directory. It then defines specific natural language instructions to replace a line of text while preserving the file header. The core functionality is executed within an asynchronous `main` function, which calls `edit_file` with parameters such as the file path, instructions, and verbose logging enabled. The script handles the tool's output, which includes a success boolean, an error message string, and the total USD cost of the API transaction. By providing a clear example of parameter usage—including model selection, caching behavior, and iteration limits—the script acts as a practical guide for developers looking to integrate automated, LLM-driven file editing into their own applications while monitoring costs and execution status.",2025-12-31T17:56:16.846685+00:00
"src/examples/cost_tracker_utility_example.py","The script is an executable example illustrating how to use utilities from the cost tracker module in the repository. It adjusts the Python path to ensure that project root and src directories are importable, then brings in calculate_cost, get_model_pricing, and normalize_model_name. The demonstrate_operations function walks through five steps. Step one resolves pricing for a specific Claude model alias, showing normalization and per-million input/output rates. Step two calculates cost for a straightforward request with 1200 input and 400 output tokens. Step three shows the impact of cache operations by supplying cache write and read tokens, noting that writes cost 25% more and reads cost 10% of the standard input rate. Step four tests fallback pricing for a newer experimental model string, handling both success and failure. Step five iterates over invalid cases (e.g., missing model identifier, negative token counts, incorrect types, and unknown models) to exercise error handling via try/except blocks. The script concludes by running demonstrate_operations when executed directly, with logging configured for INFO-level, plain message output, and printing results for each step to the console.",2025-12-30T00:42:16.799479+00:00
"src/examples/think_tool_capability_example.py","This Python script provides a demonstration of the 'invoke_with_thinking' function from the 'edit_file_tool' package, specifically designed to leverage the extended reasoning capabilities of Claude 3.7+ models. The code begins by configuring the system path to ensure proper module imports and then defines an asynchronous function, 'demonstrate_thinking_capability'. This function illustrates the end-to-end workflow for interacting with advanced AI models, including environment setup for the Anthropic API, model selection, and the preparation of complex user messages and tool definitions. The script highlights key features of the utility, such as automatic 'thinking' budget allocation, provider-specific configuration for Anthropic and Vertex AI, and a fallback mechanism for standard completions. Upon execution, the script invokes the model to process a refactoring request, subsequently parsing the response to display distinct blocks for internal reasoning (thinking), final text output, and tool usage requests. Additionally, it utilizes an internal utility to calculate and display the transaction cost and token usage, providing a comprehensive example of how to integrate and monitor sophisticated AI reasoning within a Python application.",2025-12-31T17:52:42.277022+00:00
