---
name: architecture/architecture_json
description: Unified architecture template for multiple tech stacks
version: 1.0.0
tags: [architecture, template, json]
language: json
output: architecture.json
post_process_python: ./pdd/render_mermaid.py
post_process_args:
  - "{INPUT_FILE}"
  - "{APP_NAME}"
  - "{OUTPUT_HTML}"
variables:
  APP_NAME:
    required: false
    type: string
    description: Optional app name for context.
    example: Shop
  PRD_FILE:
    required: true
    type: path
    description: Primary product requirements document (PRD) describing scope and goals.
    example_paths: [PRD.md, docs/specs.md, docs/product/prd.md]
    example_content: |
      Title: Order Management MVP
      Goals: Enable customers to create and track orders end-to-end.
      Key Features:
        - Create Order: id, user_id, items[], total, status
        - View Order: details page with status timeline
        - List Orders: filter by status, date, user
      Non-Functional Requirements:
        - P95 latency < 300ms for read endpoints
        - Error rate < 0.1%
  TECH_STACK_FILE:
    required: false
    type: path
    description: Tech stack overview (languages, frameworks, infrastructure, and tools).
    example_paths: [docs/tech_stack.md, docs/architecture/stack.md]
    example_content: |
      Backend: Python (FastAPI), Postgres (SQLAlchemy), PyTest
      Frontend: Next.js (TypeScript), shadcn/ui, Tailwind CSS
      API: REST
      Auth: Firebase Auth (GitHub Device Flow), JWT for API
      Infra: Vercel (frontend), Cloud Run (backend), Cloud SQL (Postgres)
      Observability: OpenTelemetry traces, Cloud Logging
  DOC_FILES:
    required: false
    type: list
    description: Additional documentation files (comma/newline-separated).
    example_paths: [docs/ux.md, docs/components.md]
    example_content: |
      Design overview, patterns and constraints
  INCLUDE_FILES:
    required: false
    type: list
    description: Specific source files to include (comma/newline-separated).
    example_paths: [src/app.py, src/api.py, frontend/app/layout.tsx, frontend/app/page.tsx]
usage:
  generate:
    - name: Minimal (PRD only)
      command: pdd generate --template architecture/architecture_json -e PRD_FILE=docs/specs.md --output architecture.json
    - name: With tech stack overview
      command: pdd generate --template architecture/architecture_json -e PRD_FILE=docs/specs.md -e TECH_STACK_FILE=docs/tech_stack.md --output architecture.json

discover:
  enabled: false
  max_per_pattern: 5
  max_total: 10

output_schema:
  type: array
  items:
    type: object
    required: [reason, description, dependencies, priority, filename, filepath]
    properties:
      reason: { type: string }
      description: { type: string }
      dependencies: { type: array, items: { type: string } }
      runtimeDependencies: { type: array, items: { type: string } }
      devDependencies: { type: array, items: { type: string } }
      optionalDependencies: { type: array, items: { type: string } }
      externalApiDependencies: { type: array, items: { type: string } }
      priority: { type: integer, minimum: 1 }
      filename: { type: string }
      filepath: { type: string }
      tags: { type: array, items: { type: string } }
      interface:
        type: object
        properties:
          type: { type: string, enum: [component, page, module, api, graphql, cli, job, message, config, utility, async_module, package_config] }
          component: { type: object }
          page:
            type: object
            properties:
              route: { type: string }
              params:
                type: array
                items:
                  type: object
                  required: [name, type]
                  properties:
                    name: { type: string }
                    type: { type: string }
                    description: { type: string }
              dataSources:
                type: array
                items:
                  type: object
                  required: [kind, source]
                  properties:
                    kind: { type: string, enum: [api, query, stream, file, cache, message, job, other] }
                    source: { type: string }
                    method: { type: string }
                    description: { type: string }
                    auth: { type: string }
                    inputs: { type: array, items: { type: string } }
                    outputs: { type: array, items: { type: string } }
                    refreshInterval: { type: string }
                    notes: { type: string }
              layout: { type: object }
          module: { type: object }
          api: { type: object }
          graphql: { type: object }
          cli:
            type: object
            properties:
              commands:
                type: array
                items:
                  type: object
                  required: [name]
                  properties:
                    name: { type: string }
                    args: { type: array, items: { type: string } }
                    flags:
                      type: array
                      items:
                        type: object
                        required: [name, type]
                        properties:
                          name: { type: string }
                          type: { type: string }
                          default: { type: string }
                          description: { type: string }
                          choices: { type: array, items: { type: string } }
                    exitCodes: { type: array, items: { type: integer } }
                    description: { type: string }
              io:
                type: object
                properties:
                  stdin: { type: string }
                  stdout: { type: string }
              entryPoint: { type: string }
              configFile: { type: string }
          job: { type: object }
          message: { type: object }
          config: { type: object }
          utility:
            type: object
            properties:
              purpose: { type: string }
              functions:
                type: array
                items:
                  type: object
                  required: [name, signature]
                  properties:
                    name: { type: string }
                    signature: { type: string }
                    returns: { type: string }
                    description: { type: string }
              stateless: { type: boolean }
          async_module:
            type: object
            properties:
              asyncFunctions:
                type: array
                items:
                  type: object
                  required: [name, signature]
                  properties:
                    name: { type: string }
                    signature: { type: string }
                    returns: { type: string }
                    streaming: { type: boolean }
                    errorHandling: { type: string }
                    retryPolicy: { type: string }
                    description: { type: string }
              apiWrapper: { type: boolean }
              rateLimiting: { type: string }
              costTracking: { type: boolean }
          package_config:
            type: object
            properties:
              packageType: { type: string, enum: [library, cli, both] }
              entryPoints:
                type: object
                properties:
                  scripts: { type: object }
                  console_scripts: { type: object }
              sourceLayout: { type: string, enum: [src, flat] }
              installModes: { type: array, items: { type: string } }
---

Purpose: Produce an architecture JSON that enumerates prompt files to generate code files for the project.

<PRD_FILE><include>${PRD_FILE}</include></PRD_FILE>
<TECH_STACK_FILE><include>${TECH_STACK_FILE}</include></TECH_STACK_FILE>
<DOC_FILES><include-many>${DOC_FILES}</include-many></DOC_FILES>

<INCLUDE_FILES><include-many>${INCLUDE_FILES}</include-many></INCLUDE_FILES>

INSTRUCTIONS:
- Use only the facts from the included documents and files. Do not invent technologies or filenames.
- If TECH_STACK_FILE is absent, infer a reasonable tech stack from the PRD and included files; state key assumptions within each item's description.
- Output a single top-level JSON array of items. Each item must include:
  - reason (briefly explain why this code module needs to exist), description, dependencies (filenames), priority (1 = highest), filename, filepath, optional tags.
  - Optional dependency categorization: runtimeDependencies (required for execution), devDependencies (development/tooling), optionalDependencies (feature flags/plugins), externalApiDependencies (external services/APIs).
  - interface: include only the applicable sub-object (component, page, module, api, graphql, cli, job, message, config, utility, async_module, or package_config). Omit all non-applicable sub-objects entirely.
  - When interface.type is "page", each entry in `dataSources` must be an object with at least `kind` and `source` (e.g., URL or identifier). The `kind` field MUST be exactly one of: `"api"`, `"query"`, `"stream"`, `"file"`, `"cache"`, `"message"`, `"job"`, or `"other"`. Do not invent new values like `"api/mutation"`; instead, use `"api"` (for any HTTP/REST/GraphQL endpoint) or `"other"` and describe details such as queries vs. mutations in `description` or `notes`. Provide `method`, `description`, and any other useful metadata when known.
  - For Python CLI/library projects: Use "utility" for helper modules (cost tracking, caching), "async_module" for async API wrappers, "package_config" for packaging metadata (pyproject.toml, setup.py, __init__.py).
  - For CLI interfaces: Include detailed flag definitions with types, defaults, and choices. Specify entryPoint for command registration.
- Valid JSON only. No comments or trailing commas.

OUTPUT FORMAT (authoritative):
```json
{
  "type": "array",
  "items": {
    "type": "object",
    "required": ["reason", "description", "dependencies", "priority", "filename", "filepath"],
    "properties": {
      "reason": {"type": "string"},
      "description": {"type": "string"},
      "dependencies": {"type": "array", "items": {"type": "string"}},
      "runtimeDependencies": {"type": "array", "items": {"type": "string"}},
      "devDependencies": {"type": "array", "items": {"type": "string"}},
      "optionalDependencies": {"type": "array", "items": {"type": "string"}},
      "externalApiDependencies": {"type": "array", "items": {"type": "string"}},
      "priority": {"type": "integer", "minimum": 1},
      "filename": {"type": "string"},
      "filepath": {"type": "string"},
      "tags": {"type": "array", "items": {"type": "string"}},
      "interface": {
        "type": "object",
        "properties": {
          "type": {"type": "string", "enum": ["component", "page", "module", "api", "graphql", "cli", "job", "message", "config", "utility", "async_module", "package_config"]},
          "component": {"type": "object"},
          "page": {
            "type": "object",
            "properties": {
              "route": {"type": "string"},
              "params": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["name", "type"],
                  "properties": {
                    "name": {"type": "string"},
                    "type": {"type": "string"},
                    "description": {"type": "string"}
                  }
                }
              }
            }
          },
          "module": {"type": "object"},
          "api": {"type": "object"},
          "graphql": {"type": "object"},
          "cli": {"type": "object"},
          "job": {"type": "object"},
          "message": {"type": "object"},
          "config": {"type": "object"},
          "utility": {"type": "object"},
          "async_module": {"type": "object"},
          "package_config": {"type": "object"}
        }
      }
    }
  }
}
```

INTERFACE TYPES (emit only applicable):
- page: route (string), params? (array of {name, type, description?}), dataSources? (array), layout? (object)
- component: props (array of {name, type, required?}), emits? (array), context? (array)
- module: functions (array of {name, signature, returns?, errors?, sideEffects?, async?})
- api: endpoints (array of {method, path, auth?, requestSchema?, responseSchema?, errors?})
- graphql: sdl? (string) or operations {queries?[], mutations?[], subscriptions?[]}
- cli: commands (array of {name, args?[], flags?[{name, type, default?, description?, choices?[]}], exitCodes?[], description?}), io? {stdin?, stdout?}, entryPoint? (string), configFile? (string)
- job: trigger {schedule? | event?}, inputs? (array), outputs? (array), retryPolicy? (string)
- message: topics (array of {name, direction: "publish"|"subscribe", schema?, qos?})
- config: keys (array of {name, type, default?, required?, source: "env"|"file"|"secret"})
- utility: purpose (string), functions (array of {name, signature, returns?, description?}), stateless? (boolean)
- async_module: asyncFunctions (array of {name, signature, returns?, streaming?, errorHandling?, retryPolicy?, description?}), apiWrapper? (boolean), rateLimiting? (string), costTracking? (boolean)
- package_config: packageType ("library"|"cli"|"both"), entryPoints? {scripts?, console_scripts?}, sourceLayout? ("src"|"flat"), installModes? (array)

FILENAME CONVENTIONS:
- The "filename" field is the prompt filename to generate (not the code file). Use PDD convention: <base>_<LangOrFramework>.prompt where <LangOrFramework> matches the tech stack.
- Examples (adapt to your stack):
  - Next.js (TypeScript React): page_TypeScriptReact.prompt -> generates page.tsx; layout_TypeScriptReact.prompt -> layout.tsx
  - Python backend: api_Python.prompt -> api.py; orders_Python.prompt -> orders.py
- Choose descriptive <base> names (e.g., orders_page, orders_api) and keep names consistent across dependencies.

FILEPATH CONVENTIONS:
- The "filepath" field specifies the path of the output source file from the source tree root, using conventions appropriate for the language and framework.
- Examples (adapt to your stack):
  - Next.js app router: app/orders/page.tsx, app/layout.tsx, app/api/orders/route.ts
  - Next.js pages router: pages/orders.tsx, pages/api/orders.ts
  - Python FastAPI: src/api.py, src/orders.py, src/models/order.py
  - Python CLI/library (src layout): src/package_name/__init__.py, src/package_name/cli.py, src/package_name/utils/cost_tracker.py
  - Python CLI/library (flat layout): package_name/__init__.py, package_name/cli.py, package_name/utils/cost_tracker.py
  - React components: src/components/OrderList.tsx, src/hooks/useOrders.ts
  - Config files: .env.example, pyproject.toml, package.json, setup.py, setup.cfg
- Use forward slashes (/) for path separators regardless of OS.
- Include the appropriate file extension for the target language (.tsx, .py, .rs, .go, etc.).
- Follow standard directory structures for the framework (e.g., app/ for Next.js 13+, src/ for typical React/Python projects).
- For Python packages: Use src/ layout for libraries/CLI tools to avoid import conflicts. Include __init__.py files for package structure.

DEPENDENCY RULES:
- The "dependencies" array must list other items by their prompt filenames (the "filename" values), not code filenames.
- Optional: Categorize dependencies for clarity:
  - runtimeDependencies: Modules required during execution (e.g., API clients, core utilities)
  - devDependencies: Development/build tools (e.g., linters, formatters, build scripts)
  - optionalDependencies: Feature flags or plugin systems (e.g., caching, advanced features)
  - externalApiDependencies: External services/APIs by name (e.g., "Anthropic Claude API", "OpenAI API")
- Do not reference files that are not part of this array unless they were explicitly provided via INCLUDE_FILES/DOC_FILES.
- Avoid cycles; if a cycle is necessary, justify it in the description and clarify initialization order.

PRIORITY AND ORDERING:
- Use unique integer priorities starting at 1 without gaps (1,2,3,...).
- Sort the top-level array by ascending priority.

TAGS (optional):
- Use short, lower-case tags for slicing (e.g., ["frontend","nextjs"], ["backend","api"], ["config"]).

CONTENT GUIDANCE:
- Descriptions must be architectural and actionable: responsibilities, interfaces, error handling, cross-cutting concerns.
- For API items, outline endpoints (method, path, auth) and high-level request/response shapes.
- For page/component items, include the route, key props, and data sources.
- For utility items, describe purpose, key functions, and whether it maintains state (stateless=true for pure utilities).
- For async_module items, specify async functions, whether it wraps an external API, retry/error handling strategies, rate limiting, and cost tracking capabilities.
- For package_config items, specify packageType (library/cli/both), entry points (e.g., {"edit-file": "package.cli:main"}), and source layout (src vs flat).
- For CLI items, provide detailed flag definitions including types (str/int/bool), defaults, and valid choices for enum flags.

DO NOT INCLUDE the schema or these conventions in the output; return only the JSON array.
