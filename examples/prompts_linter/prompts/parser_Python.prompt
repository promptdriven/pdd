The `parser` module is the foundational component of the PDD Prompt Linter's backend core. Its primary responsibility is to ingest raw prompt text (strings) and transform it into a structured, navigable representation (`ParsedPrompt`) that the Lint Engine can analyze. It must identify key structural elements—specifically Markdown/PDD headers and XML-style tags—while maintaining a precise mapping between these elements and their original line numbers. This line mapping is critical for generating actionable linting feedback that points users to the exact location of an issue.

Requirements
1.  **Data Structure**: Define a `ParsedPrompt` class (or dataclass) that encapsulates:
    -   `raw_text`: The original content.
    -   `lines`: A list of strings (the content split by newline).
    -   `sections`: A dictionary or list of detected sections (e.g., "Requirements", "Context"), storing the title, body text, and line range (start/end).
    -   `tags`: A list of detected XML-style tags (e.g., `<include>`, `<shell>`), storing the tag name, attributes, inner content, and line number.
2.  **Parsing Logic**: Implement a main function `parse_prompt(content: str) -> ParsedPrompt`.
3.  **Header Detection**: Support both Markdown headers (e.g., `# Title`, `## Section`) and PDD-style headers (e.g., `% Role & Scope`).
4.  **Tag Detection**: robustly identify XML tags using regex. It should detect:
    -   Self-closing tags (e.g., `<include file="..." />`).
    -   Block tags (e.g., `<shell>...</shell>`).
    -   Capture the tag name and the raw content within.
5.  **Line Mapping**: Every detected element (section or tag) must include `line_no` (or `line_start` and `line_end`). This is essential for the linter to report "Error on line 15".
6.  **Resilience**: The parser must be fault-tolerant. It should not crash on malformed Markdown or unclosed tags; it should parse what it can.
7.  **Performance**: Use efficient string manipulation and regex patterns suitable for typical source file sizes.
8.  **Dependencies**: Pure Python standard library (specifically `re`, `typing`, `dataclasses`). No external dependencies.

Dependencies
<models_findings>
  <include>context/models_findings_example.py</include>
</models_findings>

Prompt Dependencies:
None

Instructions
-   **Class Structure**: Create a `ParsedPrompt` dataclass. It should have helper methods like `get_section(name)` or `get_tags(name)` to simplify rule implementation later.
-   **Line Counting Helper**: Implement a helper (e.g., `_get_line_number(offset, newline_indices)`) to convert a regex match's character index (`match.start()`) into a 1-based line number. Pre-calculating newline indices is a good optimization.
-   **Section Parsing**:
    -   Treat a header as the start of a section.
    -   The section content extends until the next header or the end of the file.
    -   Normalize header titles (trim whitespace, remove `#` or `%`).
-   **Tag Parsing**:
    -   Use `re.finditer` to locate tags.
    -   Focus on capturing the tag name and the full match for location purposes.
    -   Do not attempt to parse attributes into a dictionary unless strictly necessary; raw attribute strings are usually sufficient for linting (e.g., checking if a file path exists in an include).
-   **Edge Cases**:
    -   Empty files.
    -   Files with no headers (treat as one "preamble" or "unknown" section).
    -   Nested tags (the regex should be non-greedy where appropriate, but a full XML parser is not required; simple matching is sufficient for the PDD spec).

Deliverable
-   `src/backend/core/parser.py`: The complete implementation of the parser module.

Implementation assumptions (explicit)
-   The input is a unicode string.
-   We assume "PDD style" headers start with `%` at the beginning of a line.
-   We assume standard Markdown headers start with `#` at the beginning of a line.
-   We do not need to validate the XML strictness (e.g., matching closing tags perfectly if nested deeply); we are "linting" structure, so identifying the presence of tags is the priority.