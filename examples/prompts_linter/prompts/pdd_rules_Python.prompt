The `pdd_rules` module contains the concrete implementations of the linting rules defined in the Prompt-Driven Development (PDD) specification. It serves as the library of logic that analyzes the parsed prompt structure (sections, tags, line maps) and emits `Finding` objects when violations are detected. This module is the core "knowledge base" of the linter, translating the heuristic guidelines of PDD (like "One prompt = one module" or "No non-deterministic directives") into executable Python code.

Requirements
1.  **Rule Implementation:** Implement the specific rules defined in the PRD (PDD001â€“PDD060) as standalone classes or functions that adhere to the interface defined in `rules_registry`.
2.  **Rule Coverage:**
    *   **PDD001 (Structure):** Detect missing Role & Scope (warn).
    *   **PDD002 (Structure):** Detect multiple unrelated target files (warn).
    *   **PDD010 (Requirements):** Detect missing Requirements section (error).
    *   **PDD011 (Requirements):** Detect requirement count outliers (<5 or >10) (warn).
    *   **PDD012 (Requirements):** Detect implementation steps disguised as requirements (warn).
    *   **PDD013 (Requirements):** Detect excess negative constraints (info).
    *   **PDD020 (IO):** Detect missing Inputs/Outputs section (warn).
    *   **PDD021 (IO):** Detect missing error-handling contract (info).
    *   **PDD030 (Context):** Detect dependencies referenced without `<include>` (warn).
    *   **PDD031 (Context):** Detect context dumps (large includes) (warn).
    *   **PDD032 (Context):** Detect missing shared preamble (info).
    *   **PDD040 (Determinism):** Detect `<shell>` or `<web>` tags (warn).
    *   **PDD050 (Size):** Detect vague prompts (small + missing IO) (warn).
    *   **PDD051 (Size):** Detect over-detailed prompts (warn).
    *   **PDD060 (Attention):** Detect critical constraints buried mid-prompt (info).
3.  **Registration:** Each rule must be automatically or explicitly registered with the `Registry` so the `LintEngine` can discover them.
4.  **Statelessness:** Rules must be pure functions or stateless classes; they take a parsed document and return a list of findings without side effects.
5.  **Evidence & Suggestions:** Every finding must include line number evidence (from the parser's line map) and a concrete `suggested_edit` snippet where applicable.
6.  **Error Handling:** Rules should be robust against malformed input; if a rule fails to execute, it should log an error but not crash the entire linting process.

Dependencies
<models_findings>
  <include>context/models_findings_example.py</include>
</models_findings>
<rules_registry>
  <include>context/rules_registry_example.py</include>
</rules_registry>
<parser>
  <include>context/parser_example.py</include>
</parser>

Prompt Dependencies:
- models_findings_Python.prompt
- rules_registry_Python.prompt
- parser_Python.prompt

Instructions
- Define a base class or interface for a Rule if one is not already provided by the registry, or strictly follow the registry's expected signature (e.g., `check(parsed_doc) -> List[Finding]`).
- Implement each rule (PDD001 through PDD060) individually. Group them logically in the file or use a class-per-rule structure.
- **PDD001 (Role & Scope):** Check the first non-comment block. If it's missing or > 5 lines without a clear "Role" or "Scope" header/keyword, trigger a warning.
- **PDD010 (Requirements):** Look for a section header containing "Requirements". If missing, return an Error finding.
- **PDD040 (Determinism):** Scan the parsed tags. If `<shell>` or `<web>` exists, return a Warning finding with a suggestion to use static files.
- **PDD050/051 (Heuristics):** Use simple token/character count estimates on the raw text or specific sections to determine "too small" or "too large".
- Ensure every `Finding` object is populated with:
    - `rule_id`: The stable ID (e.g., "PDD001").
    - `severity`: Mapped from the PRD (error, warn, info).
    - `title`: A short, human-readable summary.
    - `message`: A helpful explanation.
    - `evidence`: Line numbers derived from the parsed section/tag.
    - `suggested_edits`: A `SuggestedEdit` object with a scaffold or fix snippet.
- Use the `@register` decorator (or equivalent mechanism from `rules_registry`) to ensure rules are loaded when the module is imported.

Deliverable
- A single Python file `src/backend/rules/pdd_rules.py` containing the implementations of all standard PDD rules.

Implementation assumptions (explicit)
- The `parser` output includes a structured representation of sections (headers + content) and a list of tags found.
- The `registry` module provides a mechanism (like a decorator) to register these rules.
- Text analysis for things like "implementation steps" (PDD012) or "negative constraints" (PDD013) will be heuristic/keyword-based (e.g., counting "not", "don't", "never") rather than using NLP models, strictly adhering to the "No LLM" constraint.
